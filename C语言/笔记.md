### 指针数组和数组指针：

![](F:\Java语言学习\笔记保存的截图\Snipaste_2021-05-14_22-25-08.png)

[指针数组和数组指针](https://blog.csdn.net/weixin_42072280/article/details/83210655?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162100189516780264061776%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&request_id=162100189516780264061776&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-83210655.first_rank_v2_pc_rank_v29&utm_term=%E6%8C%87%E9%92%88%E6%95%B0%E7%BB%84%E4%B8%8E%E6%95%B0%E7%BB%84%E6%8C%87%E9%92%88)

### 一、continue-跳转控制语句

#### 基本介绍：

>continue语句用于**结束本次循环**，继续执行下一次循环。

#### 基本语法：

>```c
>{.....
>continue;
>......
>}
>```
>
>以do while使用continue为例，画出示意图：（见纸质笔记本）
>
>```c
>void main(){
>int i=1;
>while(i<=4){
>i++;
>if(i==3){
>continue;
>}
>printf("i=%d\n",i);}
>getchar();
>}
>```
>
>>输出显示：245

>```c
>int main()
>{
>int i,j;
>for(j=0;j<4;j++){
>   for(i=0;i<10;i++){
>       if(i==2){
>           continue;
>       }
>       printf("i=%d\n\a",i);
>   }
>   printf("============\n");
>}
>getchar();
>return 0;
>}
>
>```
>
>>输出：（4次）013456789

#### 注意事项：

continue语句不能单独使用，需要与==循环语句==起，也==不能和if/switch使用==。

#### 课堂练习：

>从键盘读入个数不确定的整数，并判断读入的正数和负数的个数
>
>输入为0时，结束程序【使用for循环，break，continue完成】【positive正数，negative负数】

```c
#include <stdio.h>
int main()
{
    int i;
    int positive=0;
    int negative=0;
    for(;;){//表示死循环，没有遇到break，不会退出
        printf("请输入整数：");
        scanf("%d",&i);
        if(i>0){
            positive++;
            continue;//返回循环，重新开始
        }
        else if(i<0){
            negative++;
            continue;
        }
        else if(i==0){
            break;
        }
    }
    printf("正数=%d，负数=%d",positive,negative);
    return 0;
}
```

#### continue与break:

>**continue语句：**
>
>1、该语句将导致程序忽略本次循环的剩余部分，继续开始下一次循环；
>
>2、仅可以使用在3中循环语句（while、do while、for）中（虽然使用在switch语句中，但是是嵌套在循环语句中的不算）；
>
>**break语句：**
>
>1、该语句将导致程序终止包含它的最内层循环或switch语句的剩余部分，继续执行紧跟在该循环或switch语句后的下一条语句（因此在循环或switch语句嵌套中，一个break语句仅能跳出一层循环或switch语句）；
>
>2、不仅可以使用在3中循环语句（while、do while、for）中，还可以使用在switch语句中；

---

### 二、跳转控制语句-goto

#### 基本介绍：

* C语言的goto语句可以==无条件地转移到程序中制定的行==
* goto语句通常与条件语句配合使用，可用来**实现条件转移**，跳出循环体功能。
* 在C程序设计中==一般不主张使用goto语句==，以避免造成程序流程的混乱，使理解和调剂程序都产生困哪

#### 基本语法：

>```c
>goto label(变量，指引goto转移位置)
>......(这一部分不会输出)
>label:statement
>```

#### 案列演示：

>```c
>void main(){
>printf("star\n");
>goto lable1;//lable1称为标签
>printf("ok1\n");
>  printf("ok2\n");
>  lable1://指引goto到此段落
>  printf("ok3\n");
>  printf("ok4\n");
>  getchar();
>  }
>```
>
>输出：star(换行)ok3(换行)ok4

---

### 三、枚举

#### 引出列子：

比如：一星期有七天，请定义数据表示星期一到星期天。

* 当某些量仅由有限个整型数据值组成时。

#### 传统方式：

使用`define`来完成

>#define MON 1
>
>#define TUE 2.......

#### 基本介绍：

* 枚举是C语言中的一种**构造数据类型**，它可以让数据更简洁，更易读，对于==只要几个有限的特定数据==，可以*使用枚举*
* 枚举对应英文(enumeration,简写enum)
* 枚举是一组常量的组合，包含一组==有限==的特定的数据
* 枚举语法定义格式为：

>```c
>enum 枚举名 {枚举元素1,枚举元素2,枚举元素3,....};
>```

#### 代码演示：

>```c
>int main(){
>enum DAY{ MON=1,TUE=2,WED=3,THU=4,FRI=5,SAT=6,SUM=7};
>//DAY是枚举类型，包含7个枚举
>enum DAY day;//enum DAY是枚举类型，day就是枚举变量
>day = WED;//给枚举变量day赋值，值就是某个枚举元素
>printf("%d",day);//3
>getchar();
>return 0;
>}
>```
>
>输出：3

#### 枚举的遍历：

C语言中，枚举类型是被当做int或unsigned int 类型来处理的，==枚举类型必须连续==是可以实现条件的遍历。使用for来遍历枚举元素：

>```c
>#include <stdio.h>
>enum DAY{MON=1,TUE,WED,THU,FRI,SAT,SUM}day;//如果没有赋值，就会按照顺序赋值（TUE为2，WED为3....）
>//day 表示定义了一个枚举类型enum DAY,同时定义了一个变量day(类型是enum DAY)
>int main(){
>//遍历枚举元素
>//day++会给出警告，但是可以运行
>for(day=MON;day<=SUM;day++){//要求：枚举元素连续赋值(1,2,3.....)
>printf("枚举元素：%d\n",day);
>}
>getchar;
>return 0;
>}
>
>```
>
>输出：枚举元素：1
>
>​            枚举元素：2
>
>​             ............

#### 枚举在switch中使用：

>C语言中，switch中可以使用枚举类型，例题：
>
>```c
>#include<stdio.h>/*enum SEASONS{SPRING=1,SUMMER,AUTUMN,WINTER};*/int main(){enum SEASONS{SPRING=1,SUMMER,AUTUMN,WINTER};//定义枚举类型 enum SEASONS(可将此语句写在int main主函数前面)/*如果SPRING也没有给值，则自动赋值从0开始*/enum SEASONS season;//定义了一个枚举类型变量seasonprintf("请输入你喜欢的季节：(1.spring,2.summer,3.autumn,4.winter):");scanf("%d",&season);switch(season){   case SPRING:       printf("你喜欢的季节是春天");       break;   case SUMMER:       printf("你喜欢的季节是夏天");       break;   case AUTUMN:       printf("你喜欢的季节是秋天");       break;   case WINTER:       printf("你喜欢的季节是冬天");       break;   default:       printf("你没有选择你喜欢的季节");}}
>```
>
>==注意==：
>
>* 若赋值：enum SEASONS{SPRING,SUMMER,AUTUMN=8,WINTER}
>
>* 输出：SPRING=0,SUMMER=1,AUTUMN=8,WINTER=9

#### 枚举类型使用注意事项和细节：

1. 第一个枚举成员的==默认值为整型的0==，后续枚举成员的值在前一个成员上加1（第一个成员没有被赋值的情况下）
2. 在定义枚举类型时改变枚举元素的值。

#### 枚举类型的声明：

1. 枚举变量的定义形式1: 先定义枚举类型，再定义枚举变量
2. 枚举变量的定义形式2: 定义枚举类型的同时，定义枚举变量

>```c
>enum DAY{MON=1,TUE,WED,THU,FRI,SAT,SUN}day;//定义枚举类型的同时，定义枚举变量
>```

5. 枚举变量的定义形式3：省略枚举名称，直接定义枚举变量

>```c
>enum {MON=1,TUE,WED,THU,FRI,SAT,SUM}day;//这样使用枚举，该枚举只能使用一次，因为没有命名
>```

6. 可以将整数转换为对应的枚举值（**不能直接将一个整数赋给枚举变量，但是可以将整数转成枚举类型，再赋给枚举变量**）

>```c
>int main(){enum SEASONS{SPRING=1,SUMMER,AUTUMN,WINTER};enum SEASONS season;int n=4;season=(enum SEASONS)n;//将整型数据类型n=4强制转成枚举类型，为枚举变量season赋值n=4（对应的是WINTER）printf("season=%d",season);getchar();return 0;}
>```
>
>输出：season=4

#### 枚举的补充：

>**声明枚举类型：**（声明方式与结构体相似）
>
>```c
>enum weeks {SUN,MON,TUE,WED,THU,FRI,SAT};//没有指定值时，从0开始递增
>```
>
>**利用typedef 为枚举类型定义一个别名**：
>
>```c
>typedef enum weeks {SUN,MON,TUE,WED,THU,...} WEEKS;//WEEKS将表示该枚举类型
>```
>
>**定义一个枚举类型的变量：**
>
>```c
>enum weeks today;//等价于：WEEKS today;
>```

**三问枚举数据类型：**

>**一：枚举类型是一种什么数据类型？**
>
>* 枚举类型是一种基本数据类型
> * 整型、字符型、浮点型、枚举类型  
>
>**二：枚举常量究竟是什么？**
>
>* 整型常量，不是字符串
>
> ```c
>today = MON;//等价：today = 1;today++;//等价于：today = 2;today = SUM;
> ```
>
> ```c
>printf("%d",today);//错误：printf("%s",today);
> ```
>
>* 与#define定义的宏常量类似但不同，枚举常量有作用域
>
>**三：枚举类型究竟有什么用？**
>
>* 增强程序可读性
>
> 常常用于switch语句中；
>
>* 例如：定义布尔类型，用来定义标志变量
>
> ```c
>typedef enum {FALSE,TRUE} BOOL;BOOL flag = FALSE;if(表达式){    flag = TRUE;    }
> ```

___



### 四、函数

#### 被调函数文件创建：

>code::block为例：
>
>==file -> new  -> empty file==

#### ==自定义的被调函数的声明只需在使用前声明，可在主函数中声明，也可在主函数外（可在任何位置）==

#### 为什么需要函数：

>**问题：输入两个数，再输入一个运算符（乘，除，加，减），得到结果**

>先使用传统方式来解决，看看有什么问题？
>
>* 代码冗余（有过多重复的代码）
>* 不利于代码的维护

#### 解决方法-函数：

>1. 为完成某一功能的程序指令（语句）的集合，称为==函数==
>2. 在C语言中，函数分为：==自定义函数==(程序员自己写的)、==系统函数==（查看C语言函数手册）
>3. 函数还有其他叫法，比如==方法==等.....

#### 函数的基本语法：

>```c
>返回值类型 函数名（类型 形参数1, 类型 形参数2,......）{声明语句系列;可执行语句序列;（执行语句）;//函数体return 返回值;//可选，可有可无}
>```
>
>1. 形参列表：表示函数的输入,形参可以是==值传递==，也可以==传递指针（也叫传递地址、引用传递）==
>2. 函数中的语句：表示为了实现某一功能代码块
>3. 函数可以有返回值，也可以没有，如果没有返回值，返回类型 声明为void
>4. ==注意：==不管是值传递还是引用传递(指针传递)，传递给函数的都是变量的副本，不同的是，值传递的是值的拷贝，引用传递的是地址的拷贝，一般来说，地址拷贝效率高，因为数据量小，而值拷贝决定拷贝的数据大小，数据越大，效率越低。

#### 值传递和引用传递使用特点：

1. **值传递**：变量直接存储值，内存通常在栈中分配。默认是值传递的数据类型有==基本数据类型==、==结构体==、==共用体==、枚举类型
2. **引用传递**：变量存储是一个地址，这个地址对应的空间才真正储存数据（值）。默认是引用传递的数据类型有：==指针和数组==。
3. 如果希望函数内的变量能修改函数外的变量，可以传入变量的地址&，函数内以指针的方式操作变量（*指针）。从==效果上看类似引用传递==，比如修改结构体的属性。

>```c
>//函数功能：用迭代法计算n!//函数入口参数：整型变量n表示阶乘的阶数//函数返回值：返回n! 的值long Fact(int n)   //函数定义{int 1;long result = 1;for(i=2;i<=n;i++){result*=i;}return result;//将result值作为函数的返回值返回，且return不能同时返回多个值，日发给您 返回类型与函数定义的类型一致}
>```
>
>```c
>//主函数#include<stdio.h>int main(void){int m;//long ret;printf("Input m:");scanf("%d",&m);ret = Fact(m) //调用函数Fact(),并将函数的返回值存入ret,也可不进行赋值，直接输出Fact(m)printf("%d!= %ld\n",m,ret);/*printf("%d!=%ld\n",m,Fact(m));*/return 0;}
>```
>
>==被调函数的调用过程==
>
>![主函数与被调函数调用过程](C:\Users\asus\OneDrive\图片\本机照片\QQ图片20201125111958.jpg)
>
>主函数与被调函数组合后：
>
>![](C:\Users\asus\OneDrive\图片\本机照片\QQ图片20201125142319.jpg)
>
>![](C:\Users\asus\OneDrive\图片\本机照片\QQ图片20201125142308.jpg)
>
>![QQ图片20201125142315](C:\Users\asus\OneDrive\图片\本机照片\QQ图片20201125142315.jpg)
>
>

#### 注意事项：

>* 函数返回值只能有一个，函数返回值可以是除数组以外的任何类型。函数中的return 语句可以有多个，但不表示函数可以有多个返回值。
>
>* 多个 return 语句常出现在 if-else 语句中：
>
> ![](C:\Users\asus\OneDrive\图片\本机照片\QQ图片20201125142323.jpg)
>
> * 或者：
>
>   ~~~c
>   int GetMax(int x, int y){    return x>y ? x:y; }
>   ~~~

>* printf(); 有返回值，其返回值是printf函数输出的字符的个数（空格也算一个字符）
>
>* 主函数中提供的实参数量必须与形参相等，且类型必须匹配，匹配的原则与变量赋值原则一致。
>
>* | 函数定义                               | 函数原型（声明）                                             |
>  | -------------------------------------- | ------------------------------------------------------------ |
>  | 指函数功能的确立                       | 对函数名、返回值类型、形参类型进行声明                       |
>  | 有函数体                               | 不包括函数体                                                 |
>  | 是完整独立的单位                       | 是一条语句，以分号结束，只起声明作用                         |
>  | 编译器做实事，分配内存，把函数装入内存 | 编译器对声明的态度是“我知道了”，不分配内存，只保留一个引用，执行程序链接时，将函数的内存地址链接到那个引用上（最后以 ; 号结束） |
>
> * 函数原型中的形参及其类型可以省略不写，但写上有助于参数类型匹配检查。
>
> * 函数没有返回值，参数最好用  void  来表明，否者返回值默认为  int 型
>
> * ==实参与形参（数量、类型）不匹配==：某些编译器会沉默，仅当函数原型与函数定义中的形参类型不一致时才给出编译错误。另一些编译器能捕获两者类型不匹配的错误，并发出警告。

#### 问题：把所有函数的定义都放在main函数的前面，是否可以不用函数原型了呢？

>不是
>
>* 其他函数（除主函数外）也会互相调用，可能会造成函数定义在调用之后。
>* 在程序的==开头====给出所有的函数原型==是良好的编程习惯。

* 基本数据类型默认是值传递的，即进行值拷贝。在==函数内修改==，==不会影响到原来的值==

  ```c
  #include <stdio.h>void main(){    int n = 9;    f2(n);    printf("main函数中n=%d",n);//输出为9；}int f2(int n){    n++;}
  ```

  如下程序输出为10：

  1. 

  ```c
  #include <stdio.h>void main(){    int n = 9;    n = f2(n);                //用主函数中的n接收被调函数返回值    printf("main函数中n=%d",n);//输出为10；}int f2(int n){    n++;    return n;                //返回被调函数中的n值}
  ```

                       ```c

  #include <stdio.h>
  void main()
  {
    int n = 9;
    f3(&n);                            //引入指针，需要加上地址符，传递n变量的地址 
    printf("\nmain函数中n=%d",n);       //输出n=10
  }
  void f3(int *p){
    (*p)++;                           //修改会对函数外的变量有影响
  }
                       ```

___



```c
//编写一个函数swap(int *n1,int *n2)可以交换n1和n2的值#include <stdio.h>void main(){    int n1=1;    int n2=2;    swap(&n1,&n2);    printf("main n1=%d n2=%d",n1,n2);}//1、函数名为swap//2、形参是两个指针类型 int*void swap(int *n1,int *n2){    int temp = *n1;//表示将n1这个指针指向的变量的赋值给temp    *n1 = *n2;//表示将n2这个指针指向的变量的赋值给n1这个指针指向的变量    *n2 = temp;//表示将temp赋值给n2这个指针指向的变量}
```

#### 可变函数：(==C语言支持可变函数==)

#### 断言（assert();）：

>* 测试程序中假设的正确性
>
>* 如果假设被违反，则中断程序的执行
>
>* 使用时加入头文件：include<assert.h>----------assert(判断条件);
>
>* assert();等价于:
>
>* ```c
>  void assert(int expression);expression 为真，无声无息expression 为假，中断程序

#### 程序中的假设：

>* 某个特定点的某个表达式的值一定==为真==
>* 某个特定点的某个表达式的值一定==位于某个区间等==

#### 是否可以使用条件语句代替断言？：

>* 使用断言便于在调试程序时发现错误，不会影响程序执行效率
>* 断言只能在==debug版本==中起作用，在==release版本==中不起作用，因此有仅用于==调试程序==，==不能作为程序的功能==
>* 不能用来代替条件语句来发现程序中可能会发生的错误

#### 何时使用断言：

>* 检查程序中的各种==假设的正确性==（确认是否在正确的范围之内）
>* 证实或测试某种==不可能发生的状况确实不会发生==

#### 使用断言的基本原则：

>* 使用断言捕获==不应该==或者==不可能发生==的情况
>* 每个assert只检验一个条件

#### 断言assert();使用示范：

**错误示范：**

```c
#include<stdio.h>#include<assert.h>long Fact(int n);int main(){    int m;    printf("Input m(m>=0):");    scanf("%d",&m);    assert(m>=0);//错误使用    printf("%d!=%lu\n",m,Fact(m));    return 0;}
```

**正确示范**:

```c
int MakeNumber(void){    int number;    number = rand() % 100 + 1;    assert(number>=1&&number<=100);//    return number;}
```

___



### 五、程序板式：

#### 代码行内的空格---增强单行清晰度

* 关键字之后加空格，但函数名之后不加空格

* 赋值、算术、关系、逻辑等二元运算符前后各加一空格

  * sum = sum + term;

* 但一元运算符以及[ ]    .     ->前后不加空格

* (向后紧跟，） ， ； 向前紧跟，紧跟处不留空格， , ;后留一个空格

  * Function(x, y, z)
  * for (initialization; condition; update)

* 对表达式较长的for和if语句，为了紧凑可在适当地方去掉一些空格

  * ```c
    for (i=0; i<10; i++)if ((a+b>c) && (b+c>a) && (c+a>b))
    ```

___

### 六、函数的递归调动：

* 函数直接或间接==调用自己==，称为==递归调用==

* 这样的函数称为==递归函数==：

  1. 递归是一种比迭代更强的循环结构，两者很多相似之处
  2. 递归在遇到基线条件时终止递归
  3. 如果递归永远无法回推到基线情况，则将变成无穷递归
  4. 因此，任何递归函数都必须至少有一个基线情况

  * 计算n!  :

  * 使用递归函数计算：

    ```c
    long Fact(int n){    if (n < 0) //n<0为基本条件，控制递归调用结束        return -1;    else if (n==0 || n==1)        return 1;    else      //一般条件，控制递归调用向基本条件转化，从而推出递归        return n * Fact(n-1);//当一般条件（每次减1）变成基本条件，则推出递归}
    ```

    n!=1 * 2 * 3* ......* n

    ```c
    long Fact(int n){    int i;    long result = 1;    for (i=2; i<=n; i++){        result *=1;    }    return result;}
    ```

    

  * **如果没有基本条件或者一般条件不能最终转化为基本条件会**==递归无法结束，变成无穷递归==

#### 递归的基本思想：

* 把==规模较大的==，较难解决的问题转化成==规模较小的==（**递归的一般条件**）、易于解决的==同类子问题==。
* 规模较小的子问题又转化为规模更小的子问题，且==小到一定程度可以直接得出它的解==（**递归的基本条件（终止条件，出口）**），从而得到原始问题的解。
* 函数调用时，开辟的函数栈都会完整的执行函数代码。
* 当一个==函数执行完毕，或者遇到return，==就会返回，遵守==谁调用，就将结果返回给谁==

```c
#include <stdio.h>#include <stdlib.h>void test(int n){    if(n>2){    test(n-1);           //调用的函数执行完毕会返回执行后的n值，进入printf语句    }    printf("\nn=%d",n);}void main(){    test(4);            //输入n=4的命令}
```



>递归调用的程序图：（计算阶乘）
>
>```c
>unsigned long Fact(unsigned int n){if(n==0 || n==1)return 1;else    return n*Fact(n-1);}
>```
>
>输入 n=3:
>
>![](C:\Users\asus\Pictures\Camera Roll\IMG_0022.PNG)

#### 用递归的方法计算Fibonacci数列：

Fibonacci公式：

![](C:\Users\asus\OneDrive\图片\本机照片\QQ图片20201127154246.jpg)

```c
#include <stdio.h>long Fib(int n);int main(void){    int n,i,x;    printf("请输入你要输出数列的项数 n：");    scanf("%d",&n);    for (i=1;i<=n;i++)    {        x = Fib(i);                   //调用递归函数Fibe(),计算Fibonacci数列的第n项        printf("Fib(%d) = %d\n",i,x);    }    return 0;}long Fib(int n){    if(n==1)        return 0;                     //基线情况    if(n==2)        return 1;                     //基线情况    else        return (Fib(n-1)+Fib(n-2));   //一般情况}
```

#### 普通递归与尾递归：

**普通递归：**

```c
unsigned long Fact(unsigned int n){    if(n==0 || n==1)        return 1;    else        return n*Fact(n-1);}
```

**尾递归：**

```c
unsigned long Fact(unsigned int n, unsigned int a){    if(n==0 || n==1)        return a;    else        return Fact(n-1,n*a);}
```

**普通递归与尾递归的流程图：**

![](C:\Users\asus\Pictures\Screenshots\11B06048027521E80C89468990273356.png)

#### 变量范围：

==全局变量：==不在任何语句块内定义的变量（主函数main外定义的变量）。作用域为整个程序。

==局部变量：==在除整个程序以外的其他语句块内定义的变量。

**问题：假如变量名同名：**

* 局部变量与全局变量同名：

* 局部变量隐藏全局变量，二者互不干扰；

* 形参与全局变量同名：

  * ```c
    #include <stdio.h>void Function(int x, int y);int x = 1;int y = 2;//全局变量int main(){    Function(x, y);    printf("x=%d, y=%d",x,y);    return 0;}void Function(int x, int y)//形参{    x = 2;//局部变量    y = 1;    printf("x=%d,y=%d\n",x,y);}
    ```

  **输出结果：**

  x=2,y=1//被调函数的printf输出

  x=1,y=2//主函数的printf输出

  * 局部变量隐藏（无视）全局变量，互不干扰。

* 并列语句块内的局部变量同名：

  * 互不干扰。

**结论：**==只要同名的变量出现在不同的作用域内，二者互不干扰。==

​            ==编译器只能区分不同作用域中的同名变量。==

#### 初始化局部变量与全局变量：

1. ==局部变量==，系统不会对其默认初始化，必须对局部变量初始化后才能使用

2. ==全局变量==，系统会自动对其初始化：

   | 数据类型    | 初始化默认值 |
   | ----------- | ------------ |
   | int         | 0            |
   | char        | '\0'         |
   | float       | 0.0          |
   | double      | 0.0          |
   | pointer指针 | NULL         |

3. 在==同一个作用域，变量名不能重复，==在不同的作用域，变量名可以重复，**（主函数中的n变量，n可以在被调函数中再次使用）**使用时编译器采用就近原则

4. 由{}包围的代码块也拥有独立的作用域

#### 作用域课堂练习：

1. 

```c
#include <stdio.h>double price = 200.0;//全局变量void test01(){    printf("%.2f\n",price);//该函数没有定义price，于是就是全局变量：200}void test02()              //编译器采用就近原则{    price = 250.0;         //test02函数中将全局变量price赋值为250.0（重点）    printf("%.2f\n",price);//250.0}void main()               //主函数main{    printf("main price = %.2f\n",price);//200.0    test01();              //200.0    test02();             //test02局部没有定义变量，price = 250.0直接赋值把全局变量直接修改了，因此全局变量被赋值为250.0    test01();             //由test02函数中赋值了price = 250.0    getchar();}
```

**如果将==test02函数==进行修改：**

```c
#include <stdio.h>double price = 200.0;//全局变量void test01(){    printf("%.2f\n",price);//该函数没有定义price，于是就是全局变量：200}void test02()              //编译器采用就近原则{   double price = 250.0;   //test02函数中自己定义了变量，因此不进行全局变量的修改（重点）    printf("%.2f\n",price);//250.0}void main()               //主函数main{    printf("main price = %.2f\n",price);//200.0    test01();              //200.0    test02();             //test02局部没有定义变量，price = 250.0直接赋值把全局变量直接修改了，因此全局变量被赋值为250.0    test01();             //输出200.0    getchar();}
```

2. 

```c
#include <stdio.h>int n = 10;void func1(){    int n = 20;                //局部变量，若没有 int 类型，则全局变量n被重新赋值为20；    printf("func1 n :%d\n",n);//就近原则，使用自己的n值}void func2(int n){    printf("func2 n:%d\n",n);//n是形参,由主函数的n赋值给形参，于是输出主函数的局部变量n}void func3(){    printf("func3 n:%d\n",n);//n是全局变量n}int main(){    int n = 30;             //局部变量（main函数）    func1();               //输出20    func2(n);              //输出30    func3();              //输出10         //代码块由{}包围    {        int n = 40;        printf("block n:%d\n",n);//就近原则，输出40    }    printf("main n:%d\n",n);//就近原则，寻找自己定义的n=30    getchar();    return 0;}
```

___

### 七、数组：

#### 数组介绍：

数组是可以存放多个==同一类型数据==。数组也是==一种数据类型==，是**构造类型**，传递是以引用的方式传递（即传递的是地址）

#### 一维数组案例：

>需求：计算养鸡场（6只鸡）体重的平均体重、总体重？：
>
>```c
>#include <stdio.h>int main(void){double hens[6];                       //一个double 8个字节，用函数sizeof(hens)打印内存int i,sum=0;int arrLen=sizeof(hens)/sizeof(double);//表示读入数组的元素个数printf("请输入六只鸡各个的体重：");for(i=0;i<arrLen;i++){                //不能等于arrLen,等于符号则表示输入7个元素（0—6），会造成数据溢出   scanf("%lf",&hens[i]);              //键盘打印数据到数组中，加上地址符   sum +=hens[i];                      //累计每只鸡的体重}printf("The average is %.2lf",sum/6.0);}
>```

>需求：打印26位大写字母：（A与B、C、......相邻之间ASCI码相差1）
>
>```c
>#include <stdio.h>void f1(int arr[]);int main(){int arr[26];           //定义一个26位元素的数组int i;for(i=0;i<26;i++)arr[i]='A'+i;            //A与B  ASCI码差1，与C差2.....类推for(i=0;i<26;i++){printf("%c  ",arr[i]);   //输出字符，用%c}}
>```

>需求：求出一个数组的最大值，并得到对应的下标
>
>```c
>/*定义数组大小为5假定MAX=arr[0]就是最大值，然后我们依次和数组后面的数进行比较，如果发现比有MAX更大的数，就相应的变化（把更大数赋值给MAX），当我们遍历完整个数组，MAX就是最大*/#include <stdio.h>int main(){int arr[5]={0,-1,89,99,4};int i,a=0;                   //a是MAX初始化对应数组的下标int MAX=arr[0];for(i=1;i<(sizeof(arr)/sizeof(int));i++){if(arr[i]>MAX){ MAX=arr[i];a=i;}}printf("%d的下标是%d",MAX,a);}
>```
>
>

**说明：**

1. 数组名称代表该数组首地址，即a[0]

2. 数组的各个元素是连续分布的，假如：a[0]地址0x1122       a[1]地址 : a[0]+int 字节数(4)=0x1122 + 4=0x1126

3. 数组创建后，如果没有赋值：    **全局数组默认值0**、**非全局数组初值是机器垃圾值**

4. C的数组属于**构造类型**，是引用传递（==传递的是地址==），因此当**把一个数组传递给一个函数或者变量**时，**函数或者变量 操作数组会影响到原数组**。（==数组进行传递时，只打印数组名在形参当中==）

   ```c
   #include <stdio.h>void f1(int arr[]);int main(){    int arr[3] = {3,4,5};            //原数组输出：3,4,5    int i;    f1(arr);                           //将数组传递给 f1 函数，数组传递时，只用数组名    for(i=0;i<3;i++)    {        printf("arr[%d]=%d\n",i,arr[i]);//数组被函数改变后的输出是：4,4,5    }}void f1(int arr[]){        arr[0] = arr[0]+1;            //f1函数将数组arr[]进行了改变}
   ```

5. 数组下标必须在指定范围内使用，编译通过，在==运行时会因为数组越界而异常中断==









#### 一维数组定义：

>一组具有==相同类型的变量==的集合

**数据类型**     **数组名** [**数组长度**（元素个数）]     （[]个数代表几维数组）

int a [10]                (一维数组)

* 不确定数组的长度，使用==宏定义==定义其长度：

  ```c
  #define N 10int zyy[N];
  ```

* ==静态数组和全局数组==自动初始化为0值，否者，是随机数。

* 一维数组初始化：

  * ```c
    int a[5] = {43,23,323,23,31}int a[5] = {13,31};//等价于： int a[5] = {13,31,0,0,0}int a[] = {62,74,56,88,90};//初始化给的元素个数，将直接规定该数组的长度为这时元素的个数
    ```

**更高效的数组初始化方法：**

```c
memset(a, 0, sizeof(a));//用sizeof(a)来获得数组a所占的内存字节数//需要引入头文件：#include <string.h>//将素组a所占字节数初始化为0。
```

#### 访问一维数组：

**数组名[下标]**             如：使用a数组的第三个元素 ：a[2]

#### 如何使两个数组的值相等：

> int a[4] = {1,2,3,4};
>
> int b[4];

* 方法一：逐个元素赋值

  * b[0]=a[0];
  * b[1]=a[1];
  * b[2]=a[2];
  * ..........

* 方法二：通过循环语句赋值

  * ```c
    int i;for (i=0;i<4;i++){    b[i] = a[i];}
    ```

* 更高效的数组赋值方法：

  * ```c
    memcpy(b, a, sizeof(a));//memcpy含义是内存复制的意思//将a数组的前sizeof（a）个字节复制给数组b//使用该方法时，需要保证a，b两个数组长度一致
    ```

  #### 二维数组：

  ```c
  int b[行数][列数];int month[2][month]={{30,29,30,........}                     {29,30,29,.....}}//按行分配，即一行表示闰年1-12月的天数，另一行是平年
  ```

  #### 三维数组：

  ```c
  int k[][][];
  ```

  .........

#### 数组下标越界：

![](C:\Users\asus\Pictures\Screenshots\IMG_0025(20201128-191841).PNG)

​     ==注意==：当i=8,轮到i赋值等于8，但循环还未结束，当i等于9重新赋值时，退出循环，此时i=9

![](C:\Users\asus\Pictures\Screenshots\D0FECE5953A80A398EC0A1AC6A09C34F.png)

==数组下标都是以0开始的，都是以行存储的。==

___

### 八、把数组传给函数：

#### 向函数传递一维数组：

【例】**计算平均分：计算控制---键盘输入学生人数**

```c
#include <stdio.h>#define N 40int Average(int score[],int n);void ReadScore(int score[],int n);int main(void){    int score[N],aver,n;                 //定义数组总长度为40，超出40则越界。    printf("Input n:");    scanf("%d",&n);    ReadScore(score, n);                 //不带下标的数组名代表数组的首地址。即用不带下标的数组名做函数参数    aver = Average(score, n);    printf("Average score is %d\n",aver);    return 0;}//函数功能：计算n个学生成绩的平均分int Average(int score[],int n)          //使用整型变量n作形参来传递数组的长度（40-n的位置则赋值为0）{    int i,sum=0;    for(i=0;i<n;i++){        sum += score[i];    }    return sum / n;                     //人数由输入实际人数n来决定，而非40个人。}//函数功能：输入n个学生的某门课成绩void ReadScore(int score[],int n){      //使用整型变量n作形参来传递数组的长度（40-n的位置则赋值为0）    int i;    printf("Input score:\n");    for(i=0;i<n;i++){        scanf("%d",&score[i]);    }}
```

* **若要把一个数组传递给一个函数，那么只要使用不带方括号的数组名作为函数实参调用函数即可**

#### 二维数组的使用：

**使用方式1：**

1. 语法：类型  数组名[行数] [列数];
2. 比如：int a [2] [3];
3. ==二维数组在内存的存在形式，各个元素的地址是连续分布的，即在前一个元素基础上加（该定义类型占用的字节数）==

**使用方式2：（直接初始化）**

1. ```c
   类型 数组名[行数][列数]={{值1,值2,值3...},{值1,值2,值3..},{值1,值2,值3..}};类型 数组名[行数][列数]={值1,值2,值3,值4,值5..};//会自动匹配到各行各列
   ```

#### 二维数组的遍历：

**案例：**

1. 

```c
/*介绍：sizeof(map)所有元素所占字节数，sizeof(map[0])第一行（列数）所有元素所占字节数，sizeof(int) int类型一个元素所占字节数*/#include<stdio.h>#include<string.h>int main(){    int i,j;    int map[3][3]={{0,0,1},{1,1,1},{1,1,3}};//1.sizeof(map)得到这个map的数组的大小：9*4=36；//2.sizeof(map[0])得到map中，第一行有多大：3*4=12；    int row = sizeof(map)/sizeof(map[0]);// 表示：所有元素所占字节/每一行元素所占字节数    //printf("%d",sizeof(map[0]));//3.得到列，即一行中有几个元素,前面sizeof(map[0])所求的是第一行元素个数即列数*int(4)。//所以sizeof(map[0])也表示所有列所占位置)    int cols = sizeof(map[0])/sizeof(int);//列数=所以列数（一行中所有元素占字节数）/int(4)    for(i=0;i<row;i++){        for(j=0;j<cols;j++){            printf("%d  ",map[i][j]);//一行元素一行元素打印        }        printf("\n");//数组中每换一行输出结果空一排    }}
```

2. 定义二维数组，用于保存三个班。每个班五名同学成绩，并求出每个班级平均分、以及所有班级平均分分析

   * 创建一个score[3] [5]
   * 遍历，给赋值
   * 再次遍历，统计总分和平均分

   ```c
   #include <stdio.h>int main(void){    int score[3][5];    int i,j,k;    int sum1=0,sum2=0,sum3=0,sum4=0;    for(i=0;i<3;i++){        for(j=0;j<5;j++){            printf("输入学生的成绩n：\n");            scanf("%d",&score[i][j]);        }    }    //第一个班级平均分：    for(j=0;j<5;j++){        sum1+=score[0][j];        printf("%d  ",sum1);    }    printf("\n第一个班的平均分是：%d",sum1/5);    //第二个班的平均分：    for(j=0;j<5;j++){        sum2+=score[1][j];    }    printf("第二个班的平均分是：%d",sum2/5);    //第三个班的平均分：    for(j=0;j<5;j++){        sum3+=score[2][j];    }    printf("第三个班的平均分是：%d",sum3/5);    //三个班的平均分：    for(i=0;i<3;i++){        for(j=0;j<5;j++){            sum4+=score[i][j];        }    }    printf("三个班的平均分是：%d",sum4/5);}
   ```

#### 二维数组使用细节和注意事项：

1. 可以只对部分元素赋值，==未赋值的元素自动取“0”值。==

2. 如果对全部元素赋值，那么第一维的长度可以不给出。

   ```c
   int a[3][3]={1,2,3.....}可以写成：int a[][3] = {1,2,3....}
   ```

3. 二维数组可以看做是一维数组镶嵌而成的。

#### 向函数传递二位数组：

* 即向函数==传递二维数组的首地址==。

* 在**声明函数的二维数组形参**时，==不能省略数组第二维的长度==。

  * ```c
    void Swap(int a[][N],int n);
    ```

* 必须知道列数才能正确计算a [i] [j]在数组中相对于第一个元素的偏移位置。

* 元素地址 = 偏移量 + 首地址(&a[ ] [ ])

#### 数组在学生成绩管理中的应用：

* 保存n个学生一门课程的成绩

  * 用一维数组

  * ```c
    int Average(int score[],int n);//用n来指定数组的大小
    ```

  * ==通常不指定数组的长度，用另一个形参来指定数组的大小。==

* 保存n个学生的m门课程的成绩

  * 用二维数组

  * ```c
    void Average(int score[][COURSE_N],float aver[],int n);
    ```

  * ==可省略数组第一维的长度，不能省略第二维的长度。==

  * 数组aver可保存每个学生的平均分，或每门课程的平均分。

【例】计算每个学生的平均分：

```c
void AverforStud(int score[][COURSE_N],int sum[],float aver[],int n){    int i,j;    for(i=0; i<n; i++){        sum[i] = 0;        for(j=0;j<COURSE_N;j++)        {            sum[i]=sum[i] + score[i][j];        }        aver[i] = (float)sum[i] / COURSE_N;    }}
```

#### 二维数组中的指针类型：

[行指针与列指针]: https://blog.csdn.net/junbopengpeng/article/details/16821161?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522161880077516780261994263%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=161880077516780261994263&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduend~default-1-16821161.first_rank_v2_pc_rank_v29&amp;utm_term=%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E8%A1%8C%E6%8C%87%E9%92%88%E5%92%8C%E5%88%97%E6%8C%87%E9%92%88

___

### 九、static关键字修饰变量：

```c
#include <stdio.h>void main(){    static int n;//n 就是静态变量。默认初始值为0.    printf("n=%d",n);//输出 n=0；}
```

#### 局部变量使用static修饰：

1. 局部变量被static修饰后，我们称为==静态局部变量==；
2. 对应静态局部变量在声明时未赋初值，编译器也会把它初始化为0；
3. 静态局部变量存储于进程的静态存储区（全局性质），只会被初始一次，即使函数返回，它的值也会保持不变。

==只会被初始化一次==解释：

```c
#include <stdio.h>void fn_static(void){    static int n = 10;     //静态局部变量只进行一次初始化    printf("static n=%d\n",n);    n++;    printf("n++=%d\n",n);}void main(){    fn_static();          //第一次调用，初始值为10，n++则为11    fn_static();         //第二次调用，初始值语句不在进行，直接以11开始，也是输出为11,12}
```

==普通变量每次执行都需要初始化==：

```c
#include <stdio.h>void fn(void){    int n = 10;   //普通变量，每次执行都会初始化，因为n在栈中，调用一次，重新留出空间    printf("n=%d\n",n);    n++;    printf("n++=%d\n",n);}void main(){    fn();//第一次调用，初始值为10，n++则为11；    fn();//第二次调用，再次进行赋初始值为10，n++为11；}
```

#### 全局变量使用static修饰：

1. 普通全局变量对整个工程可见，其他文件可以[^使用extern外部声明后直接使用]。也就是说其他文件不能定义一个与其相同名字的变量了（否则编译器会认为它们是同一个变量），==静态全局变量仅对当前文件可见==，==其他文件不可访问==，==其他文件可以定义与其同名的变量，两者互不影响==
2. 定义不需要与其他文件共享的全局变量时，加上static关键字能够有效的降低程序模块之间的耦合，避免不同文件同名变量的冲突，且不会误使用

```c
//一个文件中：int num = 10;//另一个文件中：#include <stdio.h>extern int num;       //使用extern外部声明，直接使用另一个文件中的普通全局变量void main(){    printf("num = %d",num);//输出结果：10}
```

#### 函数使用static修饰：

> 1.函数的使用方式与全局变量类似，在函数的返回类型前加上static，就是静态函数；
>
> ```c
> //一个文件：#include <stdio.h>void fun1(void)                  //普通函数（非静态函数）{ printf("hello from fun1.\n");}static void fun2(void)          //静态函数{ printf("hello from fun2.\n");}
> ```
>
> ```c
> //另一个文件：#include <stdio.h>extern void fun1(void);//普通函数，使用extern可以直接使用另一个文件中的fun1函数void main(){ fun1();           //输出：hello from fun1. getchar();}
> ```
>
> ```c
> //另一个文件：#include <stdio.h>extern void fun2(void);//静态函数，不能使用extern来直接使用另一个文件中的fun2函数void main(){ fun2();           //运行失败 getchar();}
> ```

> 2.非静态函数可以在另一个文件中通过extern 引用；

> 3.静态函数只能在声明它的文件中可见,其他文件不能引用该函数；

> 4.不同的文件==可以使用相同名字的静态函数==，互不影响，普通函数反之。

___

### 十、字符串中常用的==系统函数==：

#### 说明：

字符串（即 字符数组）

#### 举例说明：<string.h>

1. 得到字符串长度： 

   size_t strlen(const char *str)
    计算字符串 str 的长度，直到空结束字符，但不包括空结束字符。

2. 拷贝字符串：

   char *strcpy(char *dest, const char *src)

   把 *src* 所指向的字符串复制到 *dest*。  

3. 连接字符串：

   char *strcat(char *dest,const chat *src)

   把src所指向的字符串追加到dest所指向的字符串的结尾

#### 程序分析：

```c
#include <stdio.h>#include <string.h>         //头文件声明了字符串相关的系统函数void main(){    char src[50],dest[50];     //定义了2个字符数组，大小为50    char *str = "abcdff";    printf("str.len=%d\n",strlen(str));//统计字符串大小        //注意，拷贝字符串会将原来的内容覆盖    strcpy(src,"Hello");    //表示将“Hello”拷贝到src    printf("src=%s",src);    strcpy(dest,"周泳屹");   //表示将“周泳屹”拷贝到dest    printf("%s",dest);    strcat(dest,src);      //strcat是将src字符串的内容连接到dest,但是不会覆盖dest原来的内容，而是连接    printf("最终的目标字符串：|%s|",dest);//输出内容：最终的目标字符串：|周泳屹Hello|}
```

#### 时间和日期相关函数<time.h>：

举例说明：

1. 获取当地时间：

   ```c
   char *ctime(const time_t *timer)    //返回一个表示当地时间的字符串，当地时间是基于参数timer    e.g:#include<stdio.h>#include<time.h>void main(){   time_t a;   time(&a);   printf("当前时间是%s",ctime(&a));}
   ```

2. 编写一段代码统计 函数test执行的时间

   ```c
   double difftime(time_t time1,time_t time2)    //返回time1和time2之间相差的秒数（time1-time2）    e.g:time_t start_t,end_t;double diff_t; time(&start_t);                 //初始化得到当前时间    test();                        //执行test函数    time(&end_t);                  //得到执行后的当前时间    diff_t = difftime(end_t,start_t);    printf("%.2f",diff_t);}
   ```

整体使用：（执行test（）函数一共消耗的时间）

```c
#include <stdio.h>#include <time.h>void test();int main(){    time_t curtime;                 //time_t是一个结构类型    time_t start_t,end_t;    double diff_t;    /*time(&curtime);                //初始化得到当前时间    printf("当地时间=%s",ctime(&curtime));*/    printf("程序启动.....\n");    time(&start_t);                 //初始化得到当前时间    test();                        //执行test函数    time(&end_t);                  //得到执行后的当前时间    diff_t=difftime(end_t,start_t);    printf("%.2f",diff_t);}void test(){    int sum;    int i=0;    int j=0;    for(i=0;i<77777777;i++){        sum=0;        for(j=0;j<10;j++){            sum+=j;        }    }}
```

#### 数学相关的函数<math.h>：

math.h头文件定义了各种数学函数和一个宏，这个库中所有可用的功能==都带有以个double类型的参数==，且==都返回double类型==的结果

**举例说明：**

>1. double exp(double x)
>
>  返回值是e的x次幂的值

>2. double log(double x)
>
>  返回x的自然对数（基数为e的对数）

>3. double pow(double x,double y)
>
>  返回x的y次幂

>4. double sqrt(double x)
>
>  返回值x的平方根

>5. double fabs(double x)
>
>  返回x的绝对值（x如果是整数，可以用  abs()  ）

___

### 十一、基本数据类型与字符串类型的转换：

#### 介绍：

>我们经常需要将基本数据类型转成字符串类型（即    char数组）。或者将字符串类型转成基本数据类型

#### sprintf函数的用法：

1. sprintf与printf用法很相似，sprintf函数打印到字符串中，而printf函数打印输出到屏幕上。sprintf函数在我们完成其他数据类型转换成字符串类型的操作中应用广泛

2. 该函数包含在  stdio.h头文件中

3. ```c
   #include<stdio.h>#include<time.h>void main(){    char str1[20];//字符数组，因为C语言没有专门的字符串类型，所以字符数组表示字符串    char str2[20];    char str3[20];    int a=20984,b=48090;    double d = 14.309948;    //sprintf一个系统函数，可以将结果存放到字符串中    //格式化的结果，会存放到str1中    sprintf(str1,"%d %d",a,b);//空格也将输入字符数组str1中。输出：20984 48090    sprintf(str2,"%.2f",d);//d格式化四舍五入保留2位小数 输出：14.31    sprintf(str3,"%8.2f",d);//%8.2f含义是格式化后，一共有8位，小数点占1位，小数点后数字占2位，不够用空格占位.输出：   14.31    printf("str1=%s,str2=%s,str3=%s",str1,str2,str3);}
   ```

#### 字符串类型转基本数据类型

**语法：**通过<stdlib.h>的函数调用atoi atof即可，

**案例表示：**

```c
#include<stdio.h>#include<time.h>#include<stdlib.h>void main(){    char str1[10]="123456";//字符数组，因为C语言没有专门的字符串类型，所以字符数组表示字符串    char str2[10]="12.67423";    char str3[3]="b";    char str4[4]="111";    int num1 = atoi(str1);//将str1转成一个整数(int 型 %d输出)；    short s1 = atoi(str4);//将str4转化（short 型 %d输出）；    double d = atof(str2);//将str2转成小数（double 型 %lf输出）；    char c = str3[0];    //获取到str3这个字符串（数组第一个元素"a"）（字符 型 %c输出）；    printf("num1=%d d=%f c=%c s1=%d",num1,d,c,s1);}
```

**注意事项：**

1. 在将char数组 类型转成 基本数据类型时，要==确保能够转成有效的数据==，如：我们可以把"1234"转成一个整数，不能把"hello"转成一个整数
2. 如果==格式不正确，会默认转成0==

___

### 十二、预处理命令和宏定义：

#### 预处理命令基本介绍：

1. 使用库函数之前，应该用#include引入对应的头文件。这种==以#号开头的命令称为预处理命令==。
2. 这些在编译之前对源文件进行简单加工的过程，就称为**预处理**。
3. 预处理主要是处理以#开头的命令，例如#include<stdio.h>等，预处理命令==放在所有函数之外==，而且**一般都放在源文件的前面**。
4. 预处理是C语言的一个重要功能，由**预处理程序**完成。当对一个源文件进行编译时，系统将自动调用预处理程序对源程序中的预处理部分做处理，处理完毕自动进入对源程序的编译。
5. C语言提供了多种预处理功能，如宏定义、文件包含、条件编译等，合理地使用它们会使编写的程序**便于阅读、修改、移植、调试，也有利于模块化程序设计**。

#### 预处理命令案例：

**要求：**

>开发一个C语言，让它暂停5秒以后再输出内容“hello，scar”,并且要求跨平台，在Windows和Linux下都能运行：

**提示：**

>1. windows平台下的暂停函数的原型是void Sleep(DWORD dwMilliseconds)，参数的单位是“毫秒”，位于<windows.h>头文件中。
>
>2. "Linux"平台下暂停函数的原函数是unsigned int sleep(unsigned int seconds),参数的单位是“秒”，位于<unistd.h>头文件
>
>3. #if、#elif、#endif就是预处理命令，它们都是在编译之前又预处理程序来执行
>
>4. ```c
>     #include<stdio.h>//在windows操作系统和Linux操作系统下生成的源码不一样，将不需要的语句忽略掉#if _WIN64 //如果是windows平台就执行 #include<windows.h>#include <windows.h>//#elif _linux_//否者判断是不是Linux操作系统，如果是，就引入<unistd.h>#include<unistd.h>#endif // _WIN64int main(){//不同的平台下调用不同的函数#if _WIN64     //识别windows平台Sleep(5000);//5000毫秒#elif _linux_ //识别Linux平台sleep(5);    //5秒#endif // _WIN64puts("hello,");//输出        puts 函数——输出字符串的函数getchar();return 0;}
>   ```
>
>   ```
>
>  ```
>
> ```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```
>
>```

#### puts函数用法：

> ==puts 函数——输出字符串的函数==
>
> 其一般形式为
>
> puts(字符数组)
>
> 其作用是将一个字符串（以'\0'结束的字符序列）输出到终端。加入已定义str是一个字符数组名，切=且该数组已被初始化为"China"。则执行“
>
> puts(str);
>
> 其结果是在终端上输出“China”。由于可以用printf函数输出字符串，因此puts函数用的不多。
>
> 用puts函数输出的字符串中可以包含转义字符。例如：
>
> char str[ ] = {"China\nBeijing"};
>
> puts(str);
>
> 输出
>
> China
>
> Beijing
>
> 在输出是将字符串结束标志'\0'转换成'\n'，即输出完字符串后换行。

#### 宏定义基本介绍：

>1. #define 叫做宏定义命令，预处理命令的一种，宏定义就是用一个==标识符==来==表示一个字符串==，如果在后面的代码中出现了该标识符，那么就全部替换成指定的字符串。
>
>  ```c
>#define N 100        N是宏名，100是宏的内容（宏所表示的字符串）
>  ```
>
>    1. 预处理阶段，对程序中所有出现的“宏名”，预处理器都会用宏定义中的字符串去代码，这称为“宏替换”或“宏展开”。
>    2. 宏定义是由源程序中的宏定义命令#define完成的，宏替换是由**预处理程序**完成的。

#### 宏定义的形成：

```c
#define 宏名 字符串
```

1. **#表示这是一条预处理命令**，**所有的预处理命令都以#开头**。宏名是标识符的一种，**命名规则和变量相同**。字符串可以使**数字、表达式、if语句、函数**等。

2. 这里的字符串是一般意义上的字符序列，不是和C语言中的字符串相同，==不需要双引号==

3. 程序中**反复使用的表达式**就可以**使用宏定义**。

4. ```c
   #include <stdio.h>#define M (n*n+3*n)//宏定义，宏名为M//注意：如果宏对应的字符串 有（），则省略后会有误差int main(){    int sum,n;    printf("Input a number:\n");    scanf("%d",&n);    sum = 3*M+4*M+5*M;        //宏展开：3*(n*n+3*n)+4*(n*n+3*n)+5*(n*n+3*n)    printf("sum = %d\n",sum);    getchar();    return 0;}
   ```

#### 宏定义注意事项和细节：

1. 宏定义是用宏名来==表示一个字符串==，在==宏展开时又以该字符串取代宏名==，这是一种简单的替换。字符串可以含任何字符，它可以是常数、表达式、if语句、函数等。预处理程序不会对它做任何处理，只能在编译已被宏定义展开后的源程序时发现

2. 宏定义不是说明或语句，行位不加分号，==加上分号则连分号一起替换==。

3. 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要==终止其作用域可使用#undef命令==

4. ```c
   #include <stdio.h>#define Pi 3.14159//宏定义，宏名为M//注意：如果宏对应的字符串 有（），则省略后会有误差int main(){    printf("Pi=%lf",Pi);//输出宏定义Pi值    return 0;}#undef Pi       //取消宏定义，即下面的函数输出Pi已不存在void func(){    printf("%f",Pi);//编译错误}
   ```

5. 代码中的宏名如果==被引号包围==，那么==预处理程序不对其作宏替换==

   ```c
   #include <stdio.h>#define OK 100        //宏定义OK 100;int main(){    printf("OK\n");    //宏名被引号包围，则不对它进行宏替换，输出：OK    return 0;}
   ```

6. 宏定义==允许镶嵌==，在==宏定义的字符串中可以使用已经定义的宏名==，在宏展开时由预处理程序层层代换

   ```c
   #define Pi 3.1415926#define S Pi*y*y   //Pi是已定义的宏名,此时#define S 3.1415926*y*y printf("%f",s);//在宏替换后变为：printf("%f",3.1415926*y*y);e.g:#include <stdio.h>#define Pi 3#define S Pi*4  //Pi是已定义的宏名int main(){    printf("%d",S);//输出结果：12（3*4）    return 0;}
   ```

7. 习惯宏名用大写表示，便于与变量区分，也可以用小写表示

8. 可以用宏定义表示数据类型，书写更方便

   ```c
   #define UINT unsigned intvoid main(){    UINT a,b;//宏替换后：unsigned int a,b;}
   ```

9. ==宏定义==表示数据类型和用==typedef==定义数据说明符的区别:宏定义只是简单的==字符串替换==，由预处理器来处理；**而typedef是在编译阶段由编译器处理的，它并不是简单的字符串替换**，而给原有的数据类型起以一个==新的名字==，将它作为一种新的数据类型。

#### 带参数的宏定义基本介绍：

1. C语言允许宏带有参数，在宏定义中的参数称为“形式参数”，在宏调用中的参数称为“实际参数”，==这点和函数有些类似==

2. 对**带参数的宏**，在展开过程中==不仅要进行字符串的替换，还要用实参去替换形参==

3. 带参宏定义的一般形式：

   ```c
   #define 宏名 (形参列表) 字符串    //在字符串可以含有各个形参
   ```

4. 带参宏调用的一般形式为：

   ```c
   宏名 (实参列表);
   ```

#### 带参数的宏定义案例：

```c
#include <stdio.h>#define MAX(a,b) (a>b) ? a:b          //MAX就是带参数的宏,(a,b)就是形参，(a>b)?a:b是带参数的宏的字符串，该字符串中可以使用形参int main(){    int x,y,max;                     //x,y为实参，必须要定义数据类型    printf("Input two numbers:");    scanf("%d %d",&x,&y);    //调用带参数的宏定义    //在宏替换时,（预处理，由预处理器进行），会进行字符串的提换，同时会使用实参去替换这个形参    //即宏MAX(x,y)替换后(x,y) ? x:y    max=MAX(x,y);    printf("max=%d",max);    getchar();}
```

#### 带参宏定义的注意事项和细节：

1. 带参宏定义中，==形参==(a,b)之间可以出现空格，但是==宏名==和==形参列表==（MAX与(a,b)整体）之间不能有空格出现。

   ```c
   #define MAX(a,b) (a>b)?a:b//如果写成：#define MAX (a,b)(a>b)?a:b将被认为无参宏定义，宏名MAX代表字符串(a,b)(a>b)?a:b而不是：MAX(a,b) 代表(a>b)?a:b了
   ```

2. 在**带参宏定义中，不会为形参参数分配内存**，因此==不必指明数据类型==。而在宏调用中，**实参包含了具体的数据**，要用**它们去替换形参**，因此==实参必须要指明数据类型==

3. 在宏定义中，==字符串内的形参通常要用括号括起来==，避免出错：

   ```c
   #include <stdlib.h>#define SQ(y) y*y    //带参宏定义int main(){    int a,sq;    printf("input a number :\n");    scanf("%d",&a);  sq = SQ(a+1);//宏替换：a+1*a+1  若要其是(a+1)*(a+1),则宏定义该为：#define SQ(y) (y)*(y)    printf("sq=%d\n",sq);    system("pause");     //system(“pause”);可以卡主系统控制台    return 0;}
   ```

#### 函数：system("");

**需要引入头文件**：<stdlib.h>

```c
system("pause");  //基本语句
```

>ASSOC 显示或修改文件扩展名关联。
>AT 计划在计算机上运行的命令和程序。
>ATTRIB 显示或更改文件属性。
>BREAK 设置或清除扩展式 CTRL+C 检查。
>CACLS 显示或修改文件的访问控制列表(ACLs)。
>CALL 从另一个批处理程序调用这一个。
>CD 显示当前目录的名称或将其更改。
>CHCP 显示或设置活动代码页数。
>CHDIR 显示当前目录的名称或将其更改。
>CHKDSK 检查磁盘并显示状态报告。
>CHKNTFS 显示或修改启动时间磁盘检查。
>CLS 清除屏幕。
>CMD 打开另一个 Windows 命令解释程序窗口。
>COLOR 设置默认控制台前景和背景颜色。
>COMP 比较两个或两套文件的内容。
>COMPACT 显示或更改 NTFS 分区上文件的压缩。
>CONVERT 将 FAT 卷转换成 NTFS。您不能转换
>当前驱动器。
>COPY 将至少一个文件复制到另一个位置。
>DATE 显示或设置日期。
>DEL 删除至少一个文件。
>DIR 显示一个目录中的文件和子目录。
>DISKCOMP 比较两个软盘的内容。
>DISKCOPY 将一个软盘的内容复制到另一个软盘。
>DOSKEY 编辑命令行、调用 Windows 命令并创建宏。
>ECHO 显示消息，或将命令回显打开或关上。
>ENDLOCAL 结束批文件中环境更改的本地化。
>ERASE 删除至少一个文件。
>EXIT 退出 CMD.EXE 程序(命令解释程序)。
>FC 比较两个或两套文件，并显示
>不同处。
>FIND 在文件中搜索文字字符串。
>FINDSTR 在文件中搜索字符串。
>FOR 为一套文件中的每个文件运行一个指定的命令
>FORMAT 格式化磁盘，以便跟 Windows 使用。
>FTYPE 显示或修改用于文件扩展名关联的文件类型。
>GOTO 将 Windows 命令解释程序指向批处理程序
>中某个标明的行。
>GRAFTABL 启用 Windows 来以图像模式显示
>扩展字符集。
>HELP 提供 Windows 命令的帮助信息。
>IF 执行批处理程序中的条件性处理。
>LABEL 创建、更改或删除磁盘的卷标。
>MD 创建目录。
>MKDIR 创建目录。
>MODE 配置系统设备。
>MORE 一次显示一个结果屏幕。
>MOVE 将文件从一个目录移到另一个目录。
>PATH 显示或设置可执行文件的搜索路径。
>PAUSE 暂停批文件的处理并显示消息。
>POPD 还原 PUSHD 保存的当前目录的上一个值。
>PRINT 打印文本文件。
>PROMPT 更改 Windows 命令提示符。
>PUSHD 保存当前目录，然后对其进行更改。
>RD 删除目录。
>RECOVER 从有问题的磁盘恢复可读信息。
>REM 记录批文件或 CONFIG.SYS 中的注释。
>REN 重命名文件。
>RENAME 重命名文件。
>REPLACE 替换文件。
>RMDIR 删除目录。
>SET 显示、设置或删除 Windows 环境变量。
>SETLOCAL 开始批文件中环境更改的本地化。
>SHIFT 更换批文件中可替换参数的位置。
>SORT 对输入进行分类。
>START 启动另一个窗口来运行指定的程序或命令。
>SUBST 将路径跟一个驱动器号关联。
>TIME 显示或设置系统时间。
>TITLE 设置 CMD.EXE 会话的窗口标题。
>TREE 以图形模式显示驱动器或路径的目录结构。
>TYPE 显示文本文件的内容。
>VER 显示 Windows 版本。
>VERIFY 告诉 Windows 是否验证文件是否已正确
>写入磁盘。
>VOL 显示磁盘卷标和序列号。
>XCOPY 复制文件和目录树

#### 带参宏定义与函数的区别：

1. 宏展开仅仅是字符串的替换，不会对表达式进行计算；==宏在编译之前就被处理掉了==，他==没有机会参与编译==，也不会占用内存。

2. 函数是一段可以重复使用的代码，会被编译，会给他分配内存，每次调用函数，就是执行这块内存中的代码。

3. ```c
   #include <stdlib.h>#include <stdio.h>#include <math.h>#define SQ(y)((y)*(y))   int main(){   int i= 1;   int sum;   while(i<=5){    printf("%d\n",SQ(i++));//宏展开：(i++)*(i++)}//运算：输出：1*2=2 2*3=6 3*4=12 4*5=20  因为是i++，所以先乘再自增}
   ```


#### 预处理命令总结：

>#后是指令关键字，关键字和#号之间运行存在任意个数的空白字符，整行语句构成一条预处理指令，该指令将在编译器进行编译之前对源代码做某些转换

#### 常见预处理指令：

| 指令     | 说明                                                      |
| -------- | --------------------------------------------------------- |
| #        | 空指令，无任何效果                                        |
| #include | 包含一个源代码文件                                        |
| #define  | 定义宏                                                    |
| #undef   | 取消已定义的宏                                            |
| #if      | 如果给定条件为真，则编译下面代码                          |
| #ifdef   | 如果宏已经定义，则编译下面代码                            |
| #ifndef  | 如果宏没有定义，则编译下面代码                            |
| #elif    | 如果前面的#if给定条件不为真，当前条件为真，则编译下面代码 |
| #endif   | 结束一个#if...#else条件编译块                             |

___

### 十三、字符数组与字符串：

#### 补充：

* 用函数scanf( )按s格式符不能输入==带空格的字符串==

* 使用字符串处理函数gets( )，可以输入带空格的字符串

* gets()以回车符作为字符串的终止符，同时将回车符从输入缓冲区读走，但不作为字符串的一部分。而scanf()不读走回车符，回车符仍留在输入缓冲区中==（可以用getchar()读走换行符）==。

* 函数puts()用于从括号内的参数给出的地址开始，依次输出存储单元中的字符，当遇到第一个'\0'时输出结束，并且自动==输出一个换行符==

* fgets()可以限制输入字符串长度的函数：

  * ```c
    char name[10];fgets(name,sizeof(name),stdin);//限制输入字符串长度不超过数组大小
    ```

  * 从标准输入stdin中读取一行长度为sizeof(name)的字符串送到name为首地址的存储区中

* ==字符串比较大小时：==实际上是根据两字符对比时出现的第一对不相等的字符大小来决定他们所在字符串的大小的。（比较ASCII码值的大小）

* 循环遍历字符串时一般使用是否出现'\0'来判断是否退出循环

* 向函数传递字符串时，既可以使用字符串数组作函数参数，也可以使用字符指针做函数参数

#### 字符串在指针的输出：

```c
#include<stdio.h>int main(void){    int i = 0;    char b[] = "program";    char *a = "PROGRAM";    printf("%c%s\n",*a,b+1);//Program}
```

#### 字符数组的基本介绍：

用来存放字符的数组称为字符数组。

如：

```c
char a[10];//一维字符数组char b[5][10];//二维字符数组char c[20]={'c','p','r','o','g','a','m'}//给部分数组元素赋值
```

**字符数组实际上是一系列字符的集合，也就是字符串（string)。C语言没有专门的字符串变量，没有string类型，通常就用一个字符数组来存放一个字符串**

```c
#include <stdio.h>int main(){    char arr[4]={'t','o','m'};//输出arr:从第一个字符开始输出，直到遇到\0，表示该字符串结束    printf("%s",arr);//%s表示输出字符串，不用数组遍历输出，用%c需要遍历输出，输出：tom}
```

1. C语言中，字符串实际上是使用null字符('\0')终止的一维字符数组。因此，一个以null结尾的字符串，包含了组成字符串的字符

   char arr[4]={'t','o','m'}而言：

   内存格式：t   o   m   \0     即：若后面内存没有赋值，则后面自动存储为  \0 

2. =='\0'是ASCII码表中的第0个字符==，用NULL表示，称为空字符。该字符既不能显示，也不是控制字符，输出该字符不会有任何效果，他==在C语言中仅作为字符串的结束标志==。

3. ```c
   思考：1. char str[3]={'a','b','c'}   2. char str[]={'a','b','c'}   3. char str[4]={'a','b','c'} 在 printf("%s",str);的输出结果的差异：解析：1,2定义式输出除了abc还可能会有乱码，3输出结果只有abc。因为：1,2中定义的元素将数组定义的空间占满，没有'\0'的位置，即没有字符串的结束标志，输出中寻找'\0'时会有其他字符的的输出。3定义式留有'\0'的空间，系统自动在末尾添加一个'\0'。同时：2可以改写成 char str[]={'a','b','c','\0'}即人工添加'\0'实现只有abc的输出。
   ```

   **结论**：在给某个**字符数组**赋值时，**赋给的元素的个数==小于==该数组的长度**，==则系统会自动在末尾添加'\0'，表示字符串结束==，**赋给的元素的个数==等于==该数组的长度**，==则不会自动添加'/0'==。

4. ==字符串数组另外二种定义方式：==

   ```c
   char greeting[]="Hello"   //这种格式系统自动添加一个'\0',但数组长度不能等于和小于元素个数//使用一个指针 pStr，指向一个字符数组:    char* pStr="hello tom";//该定义方式系统也会自动添加 '\0'
   ```

   **用指针存放一个字符串：**

   1. C语言对字符串常量"hello tom"是按字符数组处理的，在内存中**开辟了一个字符数组用来存放字符串常量**(hello tom)，程序在**定义字符串指针变量pStr时**只是==把字符串首地址（即存放字符串的字符数组的首地址）赋给pStr==
   2. printf("%s\n",pStr);可以输出 pStr指向的字符串

#### 指针定义的字符串的输出：

```c
#include<stdio.h>int main(void){    int i = 0;    char b[] = "program";    char *a = "PROGRAM";    printf("%c%s\n",*a,b+1);//Program    printf("%s\n",a)//PROGRAM}
```

#### 字符串的访问和遍历：

**因为字符串的本质就是字符数组，因此可以按照数组的方式遍历和访问某个元素即可**

#### 字符串访问和遍历案例：

```c
#include<stdio.h>#include<string.h>void main(){    char greeting[]="Hello";    int i;    int len=strlen(greeting);       //求出字符串数组的长度   len=5    printf("len=%d",len);          //输出 5    printf("\n字符串第三个字符是：%c",greeting[2]);    for(i=0;i<len;i++)    {        printf("\n%c",greeting[i]); //输出 H e l l o    }    return ;}
```

#### 数组长度的计算：sizeof()关键词与strlen()函数：

1. **sizeof()用于字符串数组长度计算：**

**所有类型数组长度的计算方式**：sizeof(数组名)/sizeof(数组类型)（由于char类型一个元素只占一个字节，于是可以用sizeof(数组名)直接表示数组长度，得到的长度值会比实际长度大（将字符数组末尾的 '\0' 算入其中）

2. **strlen()函数用于字符串长度的计算：**

引入头文件：<string.h>

strlen(函数名);      //strlen()返回的是字符数

3. **差异：**

   sizeof()计算==字符串数组长度==时会==将其末尾的 '\0' 计入其中==，于是那些系统自动添加的定义字符串数组的方式往往用==sizeof()计算出的长度比实际大1==

   strlen()需要寻找到 '\0' 才结束长度计算，且==不将 '\0' 计入其中==，若字符串数组定义没有系统自动添加的 '\0'  ,需要手动添加 '\0' ，否者输出结果是乱码。

#### 字符串的表示形式：（使用字符指针变量和字符数组两种方法表示字符串的讨论）

1. 字符数组由若干个元素组成，每个元素放一个字符；而==字符指针变量中存放的是地址==（字符串/字符数组的首地址），绝==不是将字符串放到字符指针变量中==（是字符串首地址）

2. 对字符数组只能对各个元素赋值，不能用以下方法对字符数组赋值

   ```c
   char str[14];1. str="hello tom";//错误：str实际是一个常量，不允许修改,该语句意思是将str赋值为"hello tom"2. str[0]='i';//命令数组第一个数赋值为i;
   ```

   ```c
   #include<stdio.h>#include<string.h>void main(){    char* a="Hello tom";    printf("a本身的地址=%p,a指向的地址%p\n",&a,a);  //a本身的地址是指针a的地址，不会因为字符数组的改变而改变    a = "zyy";    printf("a本身的地址=%p,a指向的地址%p\n",&a,a);  //a指向的地址是a字符串数组的地址，随字符串赋值的改变而改变字符串数组地址    printf("a=%s\n",a);//输出结果： zyy}
   ```

   

3. 对==字符指针变量==，采用下面方法赋值也==是可以==的：

   ```c
   char* a;a="hello tom";
   ```

4. 如果==定义了一个字符数组==，那么==它有确定的内存地址==（即字符数组名是一个常量，==不可修改==）；而定义一个==字符指针变量==时，它==并未指向某个确定的字符数据==，并且==可以多次赋值==。（如上述第二条为例）

#### 字符串相关函数：

```c
strcpy(s1,s2);//复制字符串s2到字符串s1strcat(s1,s2);//连接字符串s2到字符串s1的末尾strlen(s1);//返回字符串s1的长度strcmp(s1,s2);//如果s1和s2是相同的，则返回0；如果s1<s2则返回小于0的数，如果s1>s2则返回大于0的数。ASII码比较。strchr(s1,ch);//返回一个指针，指向字符串s1中字符ch的第一次出现的位置（返回字符串中某个字符第一次出现的位置）strstr(s1,s2);//返回一个指针，指向字符串s1中字符串s2的第一次出现的位置（“hello tom”寻找“tom”出现的位置）
```

#### ==strcmp==函数补充：

**调用字符串比较函数strcmp（）**

头文件为<string.h>

作用：比较a，b两个字符串的，strcmp函数是根据ASCII码来比较两个字符串的。用a字符串的第一个字符减去b字符串的第一个字符，若第一个字符相等，则对比第二个字符，若a，b完全相等，则返回0；若a大于b，则返回大于0的数值；若a小于b，同样返回小于0的数值

#### 字符串相关函数使用案例：

```c
#include<stdio.h>#include<string.h>void main(){    char str1[12]="Hello";    char str2[12]="World";    char str3[12];    int len;    /*复制str1到str3*/    strcpy(str3,str1);    printf("str3=%s\n",str3);//输出：str1的字符串"Hello"    /*连接str1和str2*/    strcat(str1,str2);    printf("str1=%s,str2=%s\n",str1,str2);//输出：str1=HelloWorld str2=World    /*连接后str1的总长度*/    len = strlen(str1);    printf("str1的长度len=%d\n",len);//输出：len=10    return 0;}
```

#### 字符串（字符数组）使用注意事项和细节：

1. 程序中往往依靠检测 '\0' 的位置来判定字符串是否结束，而不是根据数组长度来决定字符串的长度。因此，字符串长度不会统计 '\0' ，字符数组长度会统计。(==空字符是ASCII码为0的字符==)
2. 在定义字符数组时应该估计字符串长度，保证数组长度始终大于字符串实际长度，否则，在输出字符数组时可能出现未知字符。
3. 系统对字符串常量也自动加一个 '\0' 作为结束符，例如"C Program" 共9个字符，但在内存中占10个字节，最后一个字节 '\0' 是系统自动加上的（通过sizeof()函数来验证）
4. 定义字符数组时，如果给的字符个数比数组长度小，则系统会默认将剩余的元素空间全部赋值为 '\0' 

#### 字符串定义方式：

```c
char str[]={"I am happy"};//系统自动加 \0char str2[]="I am happy";//系统自动加 \0char str3[]={'i','a','x','a','s'};//数组定义为5个空间，没有 \0 储存空间，输出有乱码char str4[5]={'C','s','s','s','a'};//没有位置存储 \0 ,输出有乱码char* str5="hello";//系统自动加 \0
```

**字符数组初始化**：

>```c
>1.用字符常量的初始化列表对数组初始化;char str[6] = {'c','h','i','n','a','\0'};2.用字符串常量直接对数组初始化（系统自动添加'\0',需要给'\0'留空间，否则字符串输出不完整）char str[6] = {"China"};char str[6] = "China";char str[] = "China";3.定义一个字符指针，使其指向一个字符串常量char *str = "China";//字符串内容不可修改//等价于：char *pstr;pstr = "Hello China"//将这句话的地址赋给pstr指针常量
>```

#### 字符串中国Mooc相关补充：

**整体输入输出字符串：**

>```c
>#define N 80//定义的空间要多出一个位置给空字符'\0'结尾char str[N+1];scanf("%s",str);printf("\n%s",str);
>```

#### puts与printf,gets与scanf:

```c
puts等价于：    puts();//puts不能再输入其他字符串一起输出printf("\n");//puts输出字符串后自动换行；
```

```c
scanf(); //不能输出带空格的字符串，gets();//可以输入带空格的字符串
```

**scanf();**

> 在用**%d输入数字或%s输入字符串**时，在开始读之前==会跳过空格、回车或制表符等空白字符==，==再次遇到这些字符时，系统认为读入结束==，因此不能输入带空格的字符串。
>
> 例如：
>
> ```c
> char str[20];scanf("%s",str);//输入：Hello worldprintf("%s",str);//输出：Hello
> ```

**gets()**

>**按行来读入数据**，==以回车换行作为终止符==（换句话说：除了回车符，其余都能读入字符串中），可输入带空格的字符串，因为空格和制表符都是字符串的一部分
>
>例如：
>
>```c
>char str[20];gets(str);//Hello worldprintf("%s",str);//Hello world
>```

==scanf();输入换行符时，回车不能被scanf();输入，而进入缓冲区中，等待下次输入（能将回车符输入的输出函数gets();）==

```c
#include<stdio.h>#include<stdlib.h>#define N 80int main(){    char name[N+1];    printf("Input your name:\n");    scanf("%s",name);//输入Hello后回车    puts(name);//输出;Hello    gets(name);//不显示输入，直接系统输入scanf();中进入缓冲区的回车，表示结束    puts(name);//输出：换    return 0;}
```

>gets()可以读走缓冲区中的换行符：
>
>```c
>#include<stdio.h>#include<stdlib.h>#define N 80int main(){char name[N+1],ch;printf("Input your name:\n");gets(name);//gets()将回车从缓冲区读走，所以getchar()等待用户输入printf("%s\n",name);printf("Input character；\n");ch = getchar();printf("%c\n",ch);return 0;}
>```
>
>如果用scanf();读入字符串，再用getchar()读入字符:
>
>```c
>#include<stdio.h>#include<stdlib.h>#define N 80int main(){char name[N+1],ch;printf("Input your name:\n");scanf("%s",name);//输入回车，scanf()回将回车符放入缓冲区中，               //回车符会被getchar()读走，不等待用户的另外输入printf("%s\n",name);printf("Input character；\n");ch = getchar();//在此语句前加入getchar()可以清空前面的回车符printf("%c\n",ch);return 0;}
>```
>
>==注意：==使用getchar()清空回车符时，要确保前面会有回车符需要清除，否则会清除键盘输入的一个有效字符

#### 字符串常量：

```c
printf("\"How are you.\"\n");//输出："How are you."//如果字符串太长怎么表示：printf("How are you. Press \a key and then press Enter:\n");//第二行要与printf语句对齐，不能有缩进，否则当做字符串的一部分//第二种表示方法：printf("How are you. Press "      "a key and then press Enter:\n");//优点：第二行开始时不用考虑缩进问题，不会影响输出结果
```

* C语言没有提供专门的字符串数据类型
* 字符数组----每个元素都是字符类型的数组
* ==数组最后一个元素必须是'\0'才能表示字符串==

字符数组的定义和初始化：

#### 字符串处理函数：

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_16-02-42.png)

**strlen**(字符串)

>char str[10] = {"china"};
>
>printf("%d",strlen(str));
>
>问题：输出结果是5？6？10？
>
>输出：5，该输出==不包含'\0'的实际字符个数==
>
>![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_16-16-38.png)

**strcpy(目的字符数组，源字符串）**

>将后面字符串复制到前面字符数组中；
>
>第一个（目的字符数组）必须是字符数组，第二个参数可以是字符数组，也可以是字符串常量；
>
>![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_16-21-00.png)
>
>```c
>strncpy(str2,str1,n);//将最多str1里面n个字符赋值到str2中strcpy(str2,str1);//返回值是指向str2(目的字符串数组)的指针，该指针代表复制之后的字符串
>```

**strcat(目的字符数组，源字符串);**

>![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_16-29-33.png)
>
>```注释
>strncat(str2,str1,n);//将str1中前面最多n个字符添加到字符数组str2的末尾//该返回值是指向str2连接后的字符指针
>```

**strcmp(字符串1，字符串2);**

>![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_16-33-31.png)
>
>```注释
>//用== <= >=直接进行比较：str1,str2是比较两个字符数组的地址//最多比较2个字符数组中的前n个字符的大小strnmp(str2,str1,n);
>```
>
>==比较结果：==
>
>返回值**等于0**：两个字符串**相等**
>
>返回值**大于0**：前面字符串**大于**后面字符串
>
>返回值**小于0**：前面字符串**小于**后面字符串
>
>==返回值是两个字符数组对应字符之间ASCII码的差值==
>
>![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_16-42-55.png)

#### 向函数传递字符串：

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_16-44-51.png)

**编译计算实际字符个数：**

1.用字符数组传入：

```c
#include<stdio.h>#include<stdlib.h>unsigned int MyStrlen(char str[]);int main(){    char arr[30];    int len;    puts("Please input a string:");    gets(arr);//输入的空格字符也算实际长度    len = MyStrlen(arr);    printf("The string length is %d",len);    return 0;}unsigned int MyStrlen(char str[]){    int i;    int len=0;    for(i=0;str[i]!='\0';i++){        len++;    }    return len;}
```

2.用字符指针实现：

```c
#include<stdio.h>#include<stdlib.h>unsigned int MyStrlen(char *ptr);int main(){    char arr[30];    int len;    puts("Please input a string:");    gets(arr);    len = MyStrlen(arr);    printf("The string length is %d",len);    return 0;}unsigned int MyStrlen(char *ptr){    int i;    unsigned int len=0;    for(i=0;*ptr!='\0';str++){//用指针递增，实现逐个字符数组的计数，直到遇到'\0'        len++;    }    return len;}
```

* 优化这个函数的实现：

  ![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_17-01-08.png)

  ==const 保护传入的字符串不会被修改==

  **根据'\0'即表示ASCII码为0的字符，因此可以再一步优化：**

  ![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_17-06-05.png)

  

  **for语句还剩一个语句变量时，可以优化为while语句：**

  ![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_17-07-25.png)

  **用字符数组编程实现字符串复制**：

  ![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_19-20-11.png)

  * 将2个数组中每个元素遍历复制，最后   srcStr[i] = '\0' 时，循环退出，不能实现srcStr[i]与dstStr[i]最后一项（'\0'）的赋值，因此需要单独对最后一项进行赋值。

  **用字符指针编程实现字符串赋值**：

  通过间接赋值的方法：

  ![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_19-29-24.png)

  * 循环结束时缺少字符串标志，需要单独为最后一项进行赋值（'\0'）表示将字符数组结束标志单独加入到数组当中。

  **根据'\0'的ASCII码为0，即 *srcStr为0是假，则 *srcStr不为0时为真，则while语句一直执行，直到 *strStr为假（0）。同时这2个指针所指向的位置同时变动，可以将自增和赋值同时放在一个语句中。**

  ![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_19-37-24.png)

  ==当 *dstStr赋值为0时，即 *srcStr最后一项赋值给 *dstStr  时，循环结束， 此时 *dstStr 有结束的标志符，可以不用再循环外单独赋值==（const用来保护 srcStr所指向的数组不在被调函数中改变）

#### 从函数返回字符指针（指向字符串的指针）：

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_19-55-48.png)

**编写连接字符串的函数**

```c
#include<stdio.h>#include<string.h>#include<stdlib.h>#define N 80char *MyStrcat(char *dstStr,char *srcStr);int main(){    char first[2*N+1];//这个数组足够大，用于存储2个字符串的连接存放    char second[N+1];    char *result = NULL;    printf("Input the first string:\n");    gets(first);    printf("Input the second string:\n");    gets(second);    result = MyStrcat(first,second);    printf("The result is: %s\n",result);    return 0;}char *MyStrcat(char *dstStr,char *srcStr){    char *pStr = dstStr;//保存目的字符串的首地址    while(*dstStr != '\0'){ //将指针移动到字符串末尾（结束标志处）        dstStr++;    }    while(*srcStr!='\0'){        *dstStr = *srcStr;        srcStr++;        dstStr++;    }    *dstStr = '\0';    return pStr;//指向连接后的字符串的首地址}
```

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_20-37-36.png)

#### 小结：

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_20-37-50.png)

___

### 十四、C语言的排序和查找：

#### 线性查找：

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_20-48-53.png)

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_20-49-39.png)

#### 二分查找：

**用已经排好大小顺序的一段数组，从数组中间开始比较，输入的数据大时，数组比较范围的最小值 = 中间值+1，直到中间值等于输入的函数**

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_20-50-34.png)

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_20-56-03.png)

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-30_21-05-37.png)



#### 排序算法的介绍：

>排序也称排序算法，排序是==将一组数据==，==依指定的顺序进行排列的过程==

#### 排序的分类：

1. 内部排序：

   指将需要处理的所有数据都加载到**内部存储器**（内存）中进行排序

2. 外部排序：

   数据量过大，无法全部加载到内存中，需要借助外部存储进行排序

#### 冒泡排序过程：

![冒泡排序结构图解剖](C:\Users\asus\Pictures\Screenshots\QQ图片20201206142333.png)

#### 冒泡排序案例：

>需求：将{3,9,-1,10,-2}从小到大排序

普通方式：

```c
#include<stdio.h>#include <string.h>    int arr[]={3,9,-1,10,-2};    int j,t;//临时变量；void main(){//第一轮：    for(j=0;j<4;j++){        if(arr[j]>arr[j+1])        {            t=arr[j];            arr[j] = arr[j+1];            arr[j+1]=t;        }    }//第二轮：    for(j=0;j<3;j++){        if(arr[j]>arr[j+1])        {            t=arr[j];            arr[j] = arr[j+1];            arr[j+1]=t;        }    }//第三轮：    for(j=0;j<2;j++){        if(arr[j]>arr[j+1])        {            t=arr[j];            arr[j] = arr[j+1];            arr[j+1]=t;        }    }//第四轮：    for(j=0;j<1;j++){        if(arr[j]>arr[j+1])        {            t=arr[j];            arr[j] = arr[j+1];            arr[j+1]=t;        }    }    for(j=0;j<5;j++){        printf("%d  ",arr[j]);//输出结果：-2,-1,3,9,10    }}
```

* 由于每一轮循环几乎相同，只是 j 循环次数依次减少，因此可以根据镶嵌循环，将4轮循环用外循环来表示：

```c
#include<stdio.h>#include<string.h>void main(){    int arr[]={3,9,-1,10,-2};    int j,i;    int t;//临时变量；    for(i=0;i<4;i++){        for(j=0;j<4-i;j++){//4-i是根据内循环与外循环变化规律的关系得出表达式        if(arr[j]>arr[j+1])        {            t = arr[j];            arr[j] = arr[j+1];            arr[j+1] = t;        }    }    }    for(j=0;j<5;j++){        printf("%d  ",arr[j]);    }}
```

* i,j小于4的原因是数组长度是5，需要进行四轮排序，则可用sizeof()计算其长度进行带入循环中，使函数灵活性增强

```c
#include<stdio.h>#include<string.h>void main(){    int arr[]={3,9,-1,10,-2};    int j,i;    int t;//临时变量；    int len=sizeof(arr)/sizeof(int);//计算数组的长度    for(i=0;i<(len-1);i++){        for(j=0;j<(len-1-i);j++){        if(arr[j]>arr[j+1])        {            t=arr[j];            arr[j] = arr[j+1];            arr[j+1]=t;        }    }    }    for(j=0;j<len;j++){        printf("%d  ",arr[j]);    }}
```

* 同理：从大到小的排序：

```c
#include<stdio.h>#include<string.h>void main(){    int arr[]={3,9,-1,10,-2};    int j,i;    int t;//临时变量；    int len=sizeof(arr)/sizeof(int);//计算数组的长度    for(i=0;i<len-1;i++){        for(j=0;j<len-1-i;j++){        if(arr[j]<arr[j+1])//当值小时才交换数值        {            t=arr[j];            arr[j] = arr[j+1];            arr[j+1]=t;        }    }    }    for(j=0;j<len;j++){        printf("%d  ",arr[j]);    }}
```

#### 数组的查找：顺序查找；

```c
/*有一个随机10位数组，从键盘随机输入一个数，判断该数列中是否包含此数【顺序查找】，如果找到此数，则输出下标志，如果没有此数，则输出 没有找到这个数*/#include <stdio.h>#include <string.h>#define N 40int main(){    int arr[10]={1,2,5,6,8,2,3,5,8,9};    int arrLen;    int val,n;    arrLen=sizeof(arr)/sizeof(int);    printf("Please input a number:\n");    scanf("%d",&val);    n=seqSearch(arr,arrLen,val);    if(n==-1){        printf("没有找到这个数！\n");    }    else        printf("这个数在位置%d上！\n",n);}int seqSearch(int arr[],int arrLen,int val){    int i;    for(i=0;i<arrLen;i++)    {        if(arr[i]==val)            return i;    }    return -1;}
```

#### 二分查找（针对有序数组）

//对一个有序数组进行二分查找{1,8,10,89,1000,1234}

//输入一个数看看该数组是否存在此数，并且求出下标

```c
//我们要查找的数是findVal//先找到数组中间的数midVal，和findVal比较//如果midVal>findVal,应该在midVal的左边查找//若果midVal<findVal,应该在midVal的右边查找//如果midVal==findVal,说明找到//被调函数中使用递归函数完成//注意可能存在找不到的情况，即数组当中没有从键盘输入向对应的值#include <stdio.h>#include <string.h>int main(){    int arr[]={1,8,10,89,1000,1234};    int arrlen=sizeof(arr)/sizeof(int);//计算数组的长度    int findval,n;    printf("Input you want to find number:\n");    scanf("%d",&findval);    n = binarySearch(arr,0,arrlen-1,findval);    if(n==-1)    {        printf("Not find number!");    }    else    {        printf("The number located in %d",n);    }    return 0;}int binarySearch(int arr[],int Leftindex,int rightindex,int findval){    int midindex=(Leftindex + rightindex)/2;//寻找中值对应的角标    int midval=arr[midindex];//将midindex角标对应的数组赋值给midval    if(midindex==0||midindex==rightindex){//当中值等于最右边角标或者最左边角标，则表示已经将整个数组查找完，即该数组没有对应的数值        return -1;    }    else {    if(midval>findval)        binarySearch(arr,Leftindex,midindex-1,findval);//递归调用    else if(midval<findval)        binarySearch(arr,midindex+1,rightindex,findval);//递归调用    else        return midindex;    }}
```

___

### 十五、断点调试介绍：

![介绍](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-09_11-17-35.png)

___

### 十六、指针：

#### 指针的基本介绍：

1. 指针也就是内存的地址，所谓指针变量，也就是保存了内存地址的变量。

2. 获取变量的地址，用&，如： int num = 10,获取num的地址：&num.

3. 指针类型，指针变量存的是一个地址，这个地址指向的空间存的才是值

   如：int *ptr = &num ;  ==ptr就是指向int类型的指针变量，即ptr是int *类型。==

   ```c
   ptr-->(一个地址)004723819-->(地址指向一个值)1<--num
   ```

4. 获取指针类型所指的值，使用：*(取值符)，比如：var ptr *int ,使用 *ptr获取ptr指向的值

#### 什么是指针：

==指针==是一个变量，其**值为另一个变量的地址，即内存位置的直接地址**。像其他变量或常量一样，在==使用指针存储其他变量之前，对其进行声明。==

#### 指针变量声明的一般形式：

```c
int *ip;//一个整形的指针double *dp;//一个double型的指针float *fp;//一个浮点型的指针char *ch;//一个字符型的指针
```

#### 指针的算术运算：

>指针是一个用数值表示的地址，可以对指针进行四种运算：++、--、+、-。==指针的运算即是地址符进行该数据类型单位字节（如int型单位字节是4）的加减、自增、自减的运算。==

**用指针指向数组的各个元素的位置：**

```c
int *ptr;int arr[]={1,2,3,4,5};ptr = &arr[元素的位置];//指向数组一般的元素位置ptr = arr;          //指向数组的首地址
```

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-09_14-23-24.png)

**指针递增**

```c
#include <stdio.h>const int MAX = 3;             //常量int main(){    int var[]={10,100,200};     //int型的数组    int i,*ptr;                //ptr 是一个指向int型的指针    ptr = var ;                //ptr指向var数组的首地址    for(i=0;i<MAX;i++){        printf("var[%d]地址=%p\n",i,ptr);//依次打印数组不同位置元素的地址符        printf("存储值：var[%d]=%d\n",i,*ptr);//用地址，依次打印数组中的值        ptr++;                 //等价ptr=ptr+1(一个int的字节数);ptr存放的地址，会加（int型）4个字节    }    return 0;}
```

**指针递减**

```c
#include <stdio.h>const int MAX = 3;             //常量int main(){    int var[]={10,100,200};     //int型的数组    int i,*ptr;                //ptr 是一个指向int型的指针    ptr = &var[MAX-1] ;                //ptr指向var数组的最后一个元素的地址    for(i=MAX-1;i>=0;i--){        printf("var[%d]地址=%p\n",i,ptr);        printf("存储值：var[%d]=%d\n",i,*ptr);        ptr--;                 //等价ptr=ptr-1(一个int的字节数);ptr存放的地址，会减（int型）4个字节    }    return 0;}
```

**var[ ]与*ptr,&var与ptr关系：**

```c
#include <stdio.h>const int MAX = 3;int main(){    int var[]={10,100,200};    int i,*ptr;    ptr = var;    ptr +=2;    printf("var[2]=%d,   var[2]的地址=%p,   ptr存储的地址=%p   ptr指向的值=%d",var[2],&var[2],ptr,*ptr);    //var[2]与*ptr的输出相同，&var[2]与ptr的输出相同    return 0;}
```

#### 小结：

* 数组在内存中是连续分布的
* 当对指针进行 -- 时，指针会按照它指向的数据类型字节数大小减少，比如：int *指针，每 --，就减少4个字节（一个int型存储单位）
* 可以对指针按照指定的字节数大小进行 + 或者 - 的操作，可以快速定位你要的地址。

#### 指针的比较：

>指针可以用关系运算符进行比较，如 == 、< 、<=和 >、>=。如果p1和p2指向两个变量，比如同一个数组中的不同元素，则可对  p1 和 p2 进行大小比较，==指针的比较即比较位置的前后==：
>
>```c
>#include <stdio.h>const int MAX = 3;int main(){int var[]={10,100,200};int i,*ptr;ptr = var;//指向var的第一个元素/*if(ptr==var[0]){//类型不匹配，不能输出：ptr表示地址，var[0]则表示0位置元素的值   printf("ok1\n");}*/if(ptr==&var[0]){//都是表示首地址，输出   printf("ok2\n");}if(ptr==var){//都表示首地址，输出   printf("ok3\n");}if(ptr>=&var[1]){//都表示地址的比较，但为假，不能输出   printf("ok4\n");}return 0;}
>```
>
>将其运用于循环中：
>
>```c
>#include <stdio.h>const int MAX = 3;int main(){int var[]={10,100,200};int i=0,*ptr;ptr = var;                      //指针ptr 初始化为数组var的首地址while(ptr<=&var[MAX-2]){   printf("Address of var[%d]=%x\n",i,ptr);//%x是以十六进制形式打印    printf("Address of var[%d]=%p\n",i,ptr);//而%p是打印地址的,完全不同   printf("Value of var[%d] = %d\n",i,*ptr);   ptr++;   i++;}                              //输出10,100return 0;}
>```
>
>==拓展：%p与%x:==
>
>对于32位的指针，输出一般会是类似  0xf0001234  之类的结果。
>但对于64位的指针，结果会不一样，所以  **建议打印指针就用%p**,因为：
>**%p是打印地址的, 而%x是以十六进制形式打印, 完全不同**
>（指针的大小是不确定的，由实现决定。根据地址空间的大小，一般有16位、32位、64位的指针。尽管目前32位平台上的指针一般全是32位的，但旧的一些平台上可能有多种长度的指针）

#### 指针数组：

要让数组的元素，指向int 或者其他数据类型的地址（指针），可以使用指针数组。（一个数组中所有地址的集合在指针中形成指针数组。）

#### 指针数组定义：

```c
数据类型 *指针数组名[大小];int *ptr[3];//ptr声明为一个指针数组//由3个整数指针组成，因此，ptr中的每个元素，都是一个指向 int值的指针
```

**案例：**

```c
#include <stdio.h>const int MAX = 3;int main(){    int var[]={10,100,200};    int i=0,*ptr[3];              //定义一个整数型指针数组    for(i=0;i<MAX;i++){        ptr[i]=&var[i];            //数组的地址赋给指针数组    }    for(i=0;i<MAX;i++){           //用指针数组来获取各个值        printf("Value of var[%d]=%d\n",i,*ptr[i]);    }    return 0;}
```

#### 取指针存放的地址和自己本身的地址：

```c
int *ptr[3];printf("指针ptr自身的地址=%p",&ptr[]);printf("指针ptr存放的地址=%p",ptr[]);
```

#### 指针数组应用实例：

>编写一个程序，定义一个指向字符的指针数组来存储字符串列表，并通过遍历该指针数组，显示字符串的信息（即：定义一个指针数组，该数组的每个元素，指向的是一个字符串）

```c
#include <stdio.h>#include <string.h>const int MAX = 3;int main(){    //定义一个指针数组，该数组的每个元素，指向的是一个字符串    char *books[]={"三国演义",    "西游记",    "红楼梦",    "水浒传"};//定义多个字符数组的地址集合    int j;    for(j=0;j<4;j++){//strlen(books)计算 指针数组的长度        printf("books[%d]=%s\n",j,books[j]);//指针数组的每个元素表示一个数组字符串，                                             //前面不需要 *取值符，等价一个数组给值    }    return 0;}
```

___

### 十七、指向指针的指针（多重指针）：

#### 基本介绍：

指向指针的指针是**一种多级间接寻址的形式**，或者说是**一个指针链**。通常，**一个指针包含一个变量的地址**。当我们定义一个指向指针的指针时，==第一个指针包含了第二个指针的地址==，==第二个指针指向包含实际值的位置==

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-10_13-59-29.png)

```注释
二级指针(指向一级指针的地址)---------> 一级指针(指向实际值的地址) ---------->   实际值的地址      
```

#### 多重指针（二级）入门案例：

1. 一个指向指针的指针变量必须如下声明：

   即在变量名前放置两个星号。例如：

   ```c
   int **ptr;//声明了一个指向 int类型指针 的指针：
   ```

2. 当一个目标值被一个指针间接指向到另一个指针时，访问这个值需要使用两个星号运算符；比如：

   ```c
      **ptr;     //二级指针取*是一级指针存放的地址（实际值地址）见下面案例倒数第2行输出值，              //二级指针再取一星是实际地址取值（实际数值）
   ```

3. 案例：

   ```c
   #include <stdio.h>#include <string.h>const int MAX = 3;int main(){    int var;    int *ptr;//一级指针    int **pptr;//二级指针    var=3000;    ptr=&var;//把变量var的地址赋给 ptr    pptr=&ptr;//将 ptr 自身的地址赋值给 pptr    printf("var的地址=%p var = %d\n",&var,var);    printf("ptr的本身的地址=%p ptr存放的地址=%p  *ptr=%d\n",&ptr,ptr,*ptr);    printf("pptr本身地址=%p  pptr存放的地址=%p  **pptr=%d\n",&pptr,pptr,**pptr);    printf("*pptr=%p",*pptr);  //*pptr表示一级指针(ptr)存放的地址（实际值地址）    return 0;}
   ```

   ==输出结果：==

   ![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-10_14-51-13.png)

   

4. ==总结:==**指针的指针**存放的是==上一级指针自身的地址==，**加上取值符 * 时**，则输出的是==上一级指针存放的地址== ，**加上两个取值符 ** ** ，则输出的==是上上级指针存放的地址==，若只有2级指针，则直接输出实际值。

5. ```c
   ppptr=&pptr; //二级地址赋值给三级地址
   ```

#### 传递指针（地址）给函数：

**介绍：**

>当函数的形参类型是指针类型时，是指使用该函数时，需要==传递指针==，==或者地址==，==或者数组==（数组默认是指针传递）   给该形参。

**案例1（传递指针、地址给被调函数的参数）：**

```c
#include <stdio.h>#include <string.h>void test2(int *ptr);int main(){    int num=90;    int *p = &num;   //定义指针p和将num的地址赋给p同时进行    test2(&num);     //传地址    printf("\nmain()中的num=%d",num);//输出 num=91    test2(p);        //传指针    printf("\nmain()中的num=%d",num);//输出 num=92    return 0;}void test2(int *p){    *p += 1;         //*p访问到 num 的值，因此对 num 在 main函数 的值有影响}
```

**案例2（传递数组给被调函数的形式参数）：**

>注释：数组名本身就代表该数组首地址，因此传递数组的本质就是传递地址。

```c
//两个被调函数输出值相同#include <stdio.h>#include <string.h>double getAverage2(int *arr,int size);double getAverage(int *arr,int size);//函数声明         //前面传递数组的定义：int Average(int score[],int n);int main(){    int balance[5]={1000,2,3,17,50};        //定义一个int型的数组    double aver;    aver = getAverage(balance,5);           //传递一个指向数组的指针作为参数    printf("Average value is:%lf\n",aver);    //数组名表示数组首地址    return 0;}double getAverage(int *arr,int size)//arr 是一个指针{    int i,sum=0;    double avg;    for(i=0;i<size;i++){        //arr[0]=arr + 0;        //arr[1]=arr + 1个int字节(4)        //arr[2]=arr + 2个int字节(8)        //......(因此,arr本身的值即存放的地址不发生改变)        sum+=arr[i];                 // 该方式 arr指针存放的地址不发生改变，用角标直接访问数组元素    }    avg=(double)sum/size;    return avg;}double getAverage2(int *arr,int size){    int i,sum=0;    double avg;    for(i=0;i<size;i++){        sum += *arr;          // *arr表示取arr存放的地址的实际数值        arr++;                     //指针的++运算（自增int型字节单位），改变 arr指针存放的地址    }    avg=(double)sum/size;    return avg;}
```

### 十八、返回指针的函数：

定义：

>允许函数的返回值是一个==指针==（地址），这样的函数称为**指针函数**。

**案例：（输入两个字符串，进行长度比较，并返回指针）**

```c
#include <stdio.h>#include <string.h>char *strlong(char *str1,char *str2);//定义一个 返回值是指针 类型的函数void main(){    char str1[30],str2[30],*str;     //定义一个指针 *str 指向一个字符串    printf("请输入第一个字符串：");    gets(str1);                        //输入字符串；    printf("\n请输入第二个字符串：");    gets(str2);                        //输入字符串；    str = strlong(str1,str2);    printf("\nLonger string:%s\n",str);    getchar();    return 0;}char *strlong(char *str1,char *str2){    printf("\nstr1的长度%d str2的长度%d",strlen(str1),strlen(str2));//计算字符串的长度用函数 strlen();    if(strlen(str1)>=strlen(str2)){     //字符串长度比较        return str1;                 //返回 数组str1 数组名（数组首地址，即返回指针）    }    else    {        return str2;                 //返回 数组str2 数组名（数组首地址，即返回指针）    }}
```

#### 指针函数注意事项和细节：

1. 用指针作为函数返回值时需要注意，函数运行结束后会销毁在它内部定义的所有局部数据，包括局部变量、局部数组和形式参数，函数返回的指针不能指向这些数据

2. 函数运行结束后会销毁该函数所有的局部数据，这里所谓的销毁并**不是将局部数据所占用的内存全部清零**，而是程序放弃对它的使用权限，**后面的代码可以使用这块内存**。

   ```c
   #include <stdio.h>#include <string.h>int *func(){   int n=100;       //局部变量   return &n;}int main(){    int *p = func(),n;//p指针定义和赋值 func函数返回值 同时进行       /* 添加语句 printf("okokook--"); 可能会占用 n=100 的空间，导致不能输出 n=100; */    n = *p;           //对p存储的地址所指向的实际值赋值给n    printf("\nvalue = %d\n",n);//不一定能输出 n=100;    getchar();    return 0;}
   ```

3. C语言==不支持在调用函数时返回局部变量的地址==（返回被调函数中定义的变量的地址给主函数），如果确实有==这样的需求，需要定义局部变量为  **static**（定义在静态存储区，增加存活周期）  变量==。案例：

   ```c
   #include <stdio.h>#include <string.h>int *func(){   static int n=100;       //局部变量放在 静态存储区   return &n;}int main(){    int *p = func(),n;    //p指针定义和赋值 func函数返回值 同时进行    /* 添加语句 printf("okokook--"); 可能会占用 n=100 的空间，导致不能输出 n=100; */    n = *p;           //对p存储的地址所指向的实际值赋值给n    printf("value = %d\n",n);//由于 static修饰 将n=100定义在静态存储区，不会被销毁，                               //也不会被新语句取代 因此可以 输出 n=100;    getchar();    return 0;}
   ```

#### C程序内存布局图：

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-12_14-56-49.png)

#### 应用实例：

>编写一个函数，它会**生成10个随机数**，并使用表示指针的数组名（即第一个数组元素的地址）来返回它们

```c
#include <stdio.h>#include <string.h>#include <stdlib.h>// 取随机数 rand(); 使用需要引入头文件 <stdlib.h>int *f1();   // f1函数原型void main(){    int *p;    int i;    p=f1();//p 指向是在 f1 生成的数组的首地址（即第一个元素的地址）;    for(i=0;i<10;i++){        printf("%d  ",*(p+i));//对 指针p 进行加减后 在用取值符* 取值当前存放的地址所对应的实际值;    }}int *f1(){    static int arr[10];//必须加上static，让arr的空间在静态数据区分配,使局部变量能在主函数中正常使用;    int i;    for(i=0;i<10;i++){        arr[i]=rand();//赋值随机数给数组 arr[10] 中;    }    return arr;}
```

#### 随机函数 rand(); 使用：

1. 随机函数 rand() 产生的是一个 0~RAND_MAX之间的**整数**，在**头文件<stdlib.h>**中

2. 标准C规定 RAND_MAX 的值==不大于双字节整数的最大值 32767==。即==rand()生成的随机数在0~32767之间的整数==

3. ==改变计算机生成随机数的取值范围==：

   * 利用求余运算 rand()%b 将函数 rand() 生成的随机数变化在[0,b-1]

   * 利用 rand()%b+a 将随机数的取值范围平移到[a,a+b-1]上。

   * 例如：

     ```c
     magic = rand()%100+1;//生成一个 1到100 之间的随机数
     ```

___

### 十九、函数指针（指向函数的指针）：

#### 基本介绍：

1. **一个函数**总是**占用一段连续的内存区域**，**函数名在表达式中有时也会被转换为该函数所在内存区域的首地址**，这**和数组名非常类似**。
2. **把函数的这个==首地址==（函数名）**（或称入口地址）赋予一个==指针变量==（存储函数的首地址），**使指针变量指向函数所在的内存区域**，然后**通过指针变量就可以找到并调用该函数**。这种指针就是==函数指针==。

#### 函数指针定义：

```c
returnType (*pointerName)(param list);如：int (*pmax)(int x,int y);//x,y可以省略不写，int 后第一个括号不能省略，省略后是 返回值是指针的函数
```

>1. returnType 为函数==返回值类型==
>2. pointerName 为==指针名称==
>3. param list 为==函数参数列表==
>4. 参数列表中可以同时给出参数的类型和名称，也可以只给出参数的类型，省略参数名称
>5. 注意 （）的优先级高于 *，==第一个括号不能省略==，如果==写成returnType *pointerName(param list);就成了函数原型==，它表明函数的返回值类型为  returnType *。
>6. ==理解：==*是取值符， * pointerName表示取存在这个指针变量中的地址，即是被调函数的首地址所对应的实际值（就是这个被调函数）。

#### 应用案例：

>用函数指针来实现对函数的调用，返回两个整数中的最大值。

```c
#include <stdio.h>#include <string.h>#include <stdlib.h>int max(int a,int b);int main(){    int x,y,maxVal;    //函数指针：    //函数指针的名字是 pmax    // 第一个int表示：该函数指针指向的函数是返回int型的函数    //后2个int表示该函数指针指向的函数形参是接收两个int    int (*pmax)(int,int)=max;//定义变量指针时，将函数max首地址赋值给这个指针    printf("Input two numbers:\n");    scanf("%d%d",&x,&y);    maxVal=(*pmax)(x,y);//调用方式1：(*pmax)(x,y) 通过函数指针 去调用函数max                        //调用方式2：pmax(x,y) 调用函数 max    printf("Max value:%d pmax=%p\n",maxVal,*pmax);    printf("pmax地址=%p\n",pmax);    printf("pmax本身的地址=%p\n",&pmax);    return 0;}//max是一个函数，他接受两个int，返回较大的数int max(int a,int b){    return a>b?a:b;//三元语句，判断a,b的大小并返回}
```

==注意：==在定义指针变量时，也可以带上名称，也可以不用带名称。

___

### 二十、回调函数：

#### 基本介绍：

1. 函数指针变量可以作为某个函数的参数来使用的，回调函数就是一个==通过函数指针调用的函数==。
2. 简单的说：回调函数是由别人的函数执行时调用你传入的函数。（通过函数指针完成）

#### 应用实例：

>使用回调函数的方式，给一个整型数组 int arr[10] 赋10个随机函数

```c
#include <stdio.h>#include <string.h>#include <stdlib.h>//回调函数void initArray(int *array,int arraySize,int (*f)(void)){// f 就是函数指针（用来存储函数的地址），                                                         //它可以接收的函数是 返回int型,没有形参的函数                                                         //f 在这里被 initArray 调用，充当了回调函数的角色    int i;    for(i=0;i<arraySize;i++){            array[i]=f();//通过函数指针，调用了getNextRandomValue                        //还可以写成： array[i]=(*f)();        //被调函数没有定义数组，且传入的是主函数的地址，则array数组的改变就是主函数中myarray数组的改变    }}//获取随机值int getNextRandomValue(void){    return rand();//rand()是系统函数，会返回一个随机整数}int main(){    int myarray[10],i;//定义一个数组    //调用initArray函数    //传入了一个·函数名·（函数名本质是一个地址，需要函数指针类型来接收）    initArray(myarray,10,getNextRandomValue);    //输出赋值后的数组    for(i=0;i<10;i++){        printf("%d\n",myarray[i]);    }    printf("\n");    return 0;}
```

==个人理解回调函数==：用函数指针，将一个函数（1号元素）引入为另一函数（2号元素）的形参，使1号元素作为被调函数供2号元素调用。

#### 指针注意事项和细节：

1. 指针变量存放的是地址，从这个角度看指针的本质就是地址

2. 变量声明的时候，如果没有确切的地址赋值，为指针变量赋一个NULL【\0】值是好的编程习惯。

3. 赋为NULL值的指针被称为==空指针==，NULL指针是一个定义在标准库<stdio.h>中的值为0的常量 #define NULL 0

   ```c
   #include<stdio.h>#include<stdlib.h>int main(void){    int *p=NULL;  //空指针    // 这样定义比较危险：int *p;    int num=34;    p=&num;    printf("%d",*p);}
   ```

___

### 二十一、动态内存分布：

#### C程序中，不同数据在内存中分配说明：

1. **全局变量**----**内存中的静态存储区**（static修饰的数据类型也在静态存储区中）

2. **非静态的局部变量**----内存中的动态存储区----**stack栈**

3. **临时使用的数据**----建立动态内存分配区域，需要时随机开辟，不需要时及时释放----**heap 堆**

4. 根据需要向系统申请所需要大小的空间，由于未在声明部分定义其为变量或者数据，不能通过变量名或者数组名来引用这些数据，只能通过**指针**来引用

   ![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-13_15-19-37.png)

#### 内存动态分布的相关函数：

1. 头文件 #include <stdlib.h>声明了四个关于内存动态分配的函数
2. ==函数原型 void * malloc（usigned int size）==//malloc全称：memory allocation
   * 作用——在内存的**动态存储区(堆区)**中分配一个长度为 size 的**连续空间**。
   * 形参 size 的类型为**无符号整型**，**函数返回值是所分配区域的第一个字节的地址**，即**此函数是一个指针型函数,返回的指针指向该分配域的开头位置**。
   * 如：malloc(100); //开辟 100 字节的临时空间，返回值为其第一个字节的地址
3. ==函数原型 void  *calloc （unsigned n,unsigned size）==
   * 作用——在内存的动态存储区中分配 n个长度为 size 的连续空间，与上面那个函数作用差不多，只是**这个空间一般比较大，足以保存一个数组**
   * 用 calloc 函数**可以为一维数组开辟动态存储空间，n 为数组元素个数，每个元素长度为 size**.
   * 函数返回指向所分配域的起始位置的指针；分配不成功，返回NULL。666660
   * 如：p = calloc(50, 4)://开辟 50*4 个字节临时空间，把起始地址分配给==指针变量p==
4. ==函数原型：void free （void *p)==

   * 作用——释放变量 p 所指向的动态空间，使这部分空间能重新被其他变量使用。（当这个p所指向的空间不想用时，用此函数销毁）
   * p 是最近一次调用 calloc 或 malloc 函数时的函数返回值
   * free 函数无返回值
   * 如：free(p);//释放 p 所指向的**已分配的动态空间**
5. ==函数原型 void  *realloc （void *p，unsigned int size)==

   * 作用——重新分配 malloc 或 calloc函数获得的动态空间大小，将p指向的动态空间大小改变为 size，p 的值不变，分配失败返回 NULL

   * 如：realloc(p,50);// 将 p 所指向的已分配的动态空间改为50字节
6. ==void* 只是表示只是一个纯地址，不指向任何一个变量：==
7. ![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-13_15-47-37.png)

#### viod指针类型：

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-13_15-47-46.png)

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-13_15-47-56.png)

#### 应用实例：

>动态创建数组，输入5个学生的成绩，另外一个函数检测成绩低于60分的，输出不合格的成绩：
>
>```c
>#include<stdio.h>#include<stdlib.h>int main(){void check(int *);int *p,i;p = (int*)malloc(5*sizeof(int));//开辟5个int型字节（20个字节）for(i=0;i<5;i++){   scanf("%d",p+i);//对5个int型字节分别赋值（指针的运算）}check(p);//调用函数free(p);//销毁堆区p指向的空间getchar();return 0;}void check(int *p){int i;printf("\n不合格的成绩有;");for(i=0;i<5;i++){   if(p[i]<60){       printf("%d  ",p[i]);   }}}
>```

#### 动态分配内存的基本原则：

1. ==避免分配大量的小内存块==。分配堆上的内存有一些系统开销，所以分配许多小的内存块比分配几个大内存块的系统开销大
2. 仅在需要时分配内存。只要==使用完堆上的内存块，就需要及时释放它==（如：上个实例中的语句  free(p);  )，否者可能出现**内存泄漏**  **(如果使用动态遵守原则：谁分配，谁释放)**
3. 总是**确保释放以分配的内存**。在编写分配内存的代码时，就要确定在代码的什么地方释放内存
4. 在释放内存之前，确保不会无意中覆盖堆上已分配的内存地址，否则程序就会出现内存泄漏。**在循环中分配内存时，要特别小心**
5. ![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-14_16-51-29.png)

### 二十二、结构体：

#### 引出结构体：

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-14_16-55-02.png)

传统方案：数组，字符串数组：不利于数据的管理和维护，因为本身猫的三个属性（名字，年龄，颜色）是一个整体，传统方法是将其分解 ===>  结构体

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-14_17-39-51.png)

**利用结构体解答：**

```c
#include<stdio.h>#include<stdlib.h>int main(){    /* 1.猫有三个成员（变量）组成    2.使用结构体解决*/    //创建结构体 Cat(是数据类型)    struct Cat{//结构体名：Cat,Cat就是我们自己构造的一个数据类型        char*name;//名字，使用指针，指向一个字符串        int age;//年龄        char*color;//颜色    };    //使用Cat结构体创建变量    struct Cat cat1;//cat1就是struct Cat的一个变量    //给cat1的各个成员（变量）赋值    cat1.name="小白";    cat1.age=3;    cat1.color="白色";    struct Cat cat2;//cat2就是struct Cat的一个变量    //给cat2各个成员（变量）赋值    cat2.name="小花";    cat2.age=100;    cat2.color="花色";    printf("第一只猫 name=%s age=%d color=%s\n",cat1.name,cat1.age,cat1.color);    printf("第二只猫 name=%s age=%d color=%s\n",cat2.name,cat2.age,cat2.color);}
```

#### 结构体和结构体变量的区别和联系：

通过上面案例可以看出：

1. 结构体是==自定义的数据类型==，表示的是**一种数据结构**

2. 结构体变量代表一个具体变量，好比：

   ```c
   int num1;//int 是数据类型，而num1是一个具体的int变量struct Cat cat1;//Cat是一个结构体数据类型，而cat1是一个struct Cat变量
   ```

3. **Cat就像一个“模板”**，**定义出来的结构体变量都含有相同的成员**。也可以**将结构体比作“图纸”，将结构体变量比作“零件”**，**根据同一张图纸生产出来的零件的特征都是一样的。**

#### 结构体变量在内存中布局：

```c
struct Cat cat1;//定义一个Cat型变量catcat1.name="小白";cat1.age=3;cat1.color="白色";
```

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-14_17-40-06.png)

#### 结构体的声明：

```c
struct 结构体名称{//结构体名首字母一般大写    成员列表;}如：    struct Student{        char*name;//姓名        int num;//学号        int age;//年龄        char group;//所在小组        float score;//成绩        //成员也可以是再一个结构体    };//需要分号隔开语句块
```

#### 结构体成员：

1. 即可以称为==成员==，也可以说==结构体包含的变量==；
2. ==成员==是结构体的一个组成部分，一般是==基本数据类型==，也可以是==数组==、==指针==、==结构体==等。

#### 结构体注意事项和细节说明：

1. 成员声明语法同变量。示范：数据类型  成员名

   ```c
   struct Cat cat1;
   ```

2. 字段的类型可以为：基本类型、数组或指针、结构体等

3. 在创建一个结构体变量后，需要==给成员赋值==，如果==没有赋值就使用可能导致程序异常终止==

4. ==不同结构体变量==的成员是独立，互不影响，一个结构体变量的成员更改，不影响另外一个（如：cat1修改了变量，cat2结构体变量的成员不会受影响）

#### 创建结构体和结构体变量：

1. **方式一：**

   先定义结构体，然后创建结构体变量

   ```c
   struct Stu{    char *name;    int num;    int age;    char group;    float score;};struct Stu stu1,stu2;//定义了两个变量 stu1,stu2,它们都是Stu类型，都由5个成员组成//注意关键字struct不能少
   ```

2. **方式二：**

   在定义结构体的同时定义结构体变量

   ```c
   struct Stu{    char*name;    int num;    int age;    char group;    float score;}stu1,stu2;//在定义结构体Stu的同时，创建了两个结构体变量 stu1和stu2
   ```

3. **方式三：**

   如果==只需要stu1、stu2两个变量==，后面==不需要再使用结构体名定义其他变量==，在定义时也==可以不给出结构体名==

   ```c
   struct {//没有写Stu    char*name;    int num;    int age;    char group;    float score;}stu1,stu2;stu1.name="";stu1.num= ;.......//该结构体数据类型没有名称，匿名结构体//stu1,stu2就是该结构体的两个变量
   ```

   #### 成员的获取和赋值：

   结构体和数组类似，也是一组数据的集合，整体使用没有太大的意义。数组使用下标[ ]获取单个元素，**结构体使用点号   .    获取单个成员**。（ stu1.name="zhouyongyi"）。获取结构体成员的一般格式为：

   ```c
   结构体变量名.成员名;
   ```

**案例：**

```c
struct (Stu){    char *name;    int num;    int age;    .....}stu1={"周泳屹",11,18,...};//整体赋值，需要对应//struct Stu stu2={"ztt",11,8,...}该语句也可以对stu2定义并赋值/* struct Stu stu3;stu3={"zyr",43,21,...}   这样的语句是错误的 */
```

#### 结构体应用案例：

**步骤**：

1. 声明（定义）结构体，确定结构体名
2. 编写结构体成员
3. 编写处理结构体的函数

**需求：**

![image-20201215233855003](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20201215233855003.png)

![image-20201215233929525](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20201215233929525.png)

![image-20201215233944728](C:\Users\asus\AppData\Roaming\Typora\typora-user-images\image-20201215233944728.png)

```c
#include<stdio.h>#include<stdlib.h>//定义一个 Dog 结构体struct Dog{    char* name;    int age;    double weight;};//返回一个字符串型函数char *say(struct Dog dog){    //将这个信息放入到一个字符串（字符数组）    static char info[50];//在一个函数返回一个局部变量，则需要将这个局部变量定义为静态局部变量    sprintf(info,"name=%s age=%d weight=%.2lf",dog.name,dog.age,dog.weight);//将后面的字符串输出到 info字符数组中    dog.name="小花";//局部变量，不影响主函数的输出    return info;}void main(){    struct Dog dog;//定义一个dog变量    char *info=NULL;    //对 dog 变量进行赋值    dog.name="小黄";    dog.age=1;    dog.weight=3.4;        info=say(dog);//结构体默认值传递（复制了一个dog的空间给被调函数形参）                     //所以被调函数中的 dog变量被修改，对主函数中的输出没有影响    printf("小狗信息=%s\n",info);    printf("main小狗名字=%s",dog.name);}
```

**盒子案例：**

>需求：
>
>1. 创建一个Box结构体，定义三个成员：长，宽，高（从键盘输入数据）
>2. 定义一个函数获取立方体的体积

```c
#include<stdio.h>#include<stdlib.h>//定义一个Box结构体struct Box{    double length;    double height;    double width;    double volumn;};int main(){    struct Box box;//定义结构体        printf("Please input the length,width,height:\n");    //从键盘输入数据：    scanf("%lf,%lf,%lf",&box.length,&box.width,&box.height);    box.volumn=box.height*box.length*box.width;    //使用结构体的变量时，box. 不能省略    printf("The volumn is %.2lf\n",box.volumn);    return 0;}
```

**景区门票案例：**

需求：

>1. 根据游人的年龄不同收取不同的价格
>2. 编写游人结构体（Visitor），根据年龄段决定能够购买的门票价格并输出
>3. 规则：年龄>18，门票是20元，其他情况免费
>4. 可以循环从控制台输入名字和年龄，打印门票收费情况，如果名字输入n，则退出循环

**自己操作：**

```c
#include<stdio.h>#include<stdlib.h>#include "string.h"struct Visitor{    char name[20];    int age;};int main(){    int sum=0;    struct Visitor person;    do    {        printf("请输入姓名：\n");        scanf("%s",person.name);        if(strcmp("n",person.name)==0)            break;        printf("请输入年龄：\n");        scanf("%d",&person.age);        if(person.age>18){                sum=20;                printf("%s的年龄为：%d,门票价格为：%d\n",person.name,person.age,sum);        }        else        {            sum=0;            printf("%s的年龄为：%d,门票免费\n",person.name,person.age);        }    }while(1);    printf("计算结束，退出程序！");}
```

**标准操作（指针传入结构体）:**

```c
#include<stdio.h>#include<stdlib.h>#include<string.h>struct Visitor{    char name[10];    int age;    double pay;//应付价格};//编写函数，处理业务//应为结构体是值传递，会拷贝一份完整的数据，效率低//因此，为了提高效率，我们 直接 接收地址（指针）void ticket(struct Visitor *visitor)//接收结构体指针（地址）类型的形参{    if((*visitor).age>18){//ticket函数中visitor本身是一个指针，需要取值符获取到结构体本身的数据            //age,pay,是visitor内的变量，要访问他们，需要对visitor指针取值        (*visitor).pay=20;    }    else{        (*visitor).pay=0;    }}void main(){    //测试    //创建一个结构体变量（创建一个游客）    struct Visitor visitor;    while(1){        printf("请输入游客名字：");        scanf("%s",visitor.name);        //字符串的比较，详见前面字符串函数        if(strcmp("n",visitor.name)==0){ //visitor.name如果与n相同，则返回0            break;        }        printf("\n请输入游客年龄：");        scanf("%d",&visitor.age);        //函数调用,获取应付的票价        ticket(&visitor);//传入结构体地址给形参指针        printf("\n该游客应付票价：%ld",visitor.pay);    }    printf("\n退出程序");}
```

____

### 二十三、共用体：

#### 一个需求：

>现有一张关于学生信息和教师信息的表格。学生信息包括 姓名 、 编号 、 性别 、 职业、分数，教师的信息包括 姓
>名、编号、性别、职业、教学科目。
>
>![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-16_15-11-58.png)
>
>**传统方式：**
>
>定义结构体，根据人员的职业，使用对应的成员变量。
>struct Person{
>char name[20];
>int num;
>char sex;
>char profession;
>float score; // 学生使用 score
>char course[20]; // 老师使用 course
>} ;//有空间的浪费现象
>
>1. 使用2个结构体，struct Teacher ,struct Student
>2. 使用==共用体==。

#### 共用体基本介绍：

1. 共用体（Union）属于**构造类型**,它**可以包含多个类型不同的成员**。和结构体非常类似, 但是也有不同的地方.
   共用体有时*也被称为联合或者联合体*

2. **共用体**的定义：

   ```c
   union 共用体名{成员列表};
   ```

3. **结构体和共用体的区别**在于：**结构体的各个成员会占用不同的内存，互相之间没有影响；而共用体的所有成员
   占用同一段内存，修改一个成员会影响其余所有成员**。

#### 对共用体的定义使用：

方式一：

```c
union data{    int n;    char ch;    double f;};union data a,b,c;//定义三个结构体data类型的变量
```

方式二：

```c
union data{    int n;    char ch;    double f;}a,b,c;//定义三个结构体data类型的变量
```

方式三：

```c
union{    int n;    char ch;    double f;}a,b,c;//定义三个结构体data类型的变量
```

#### 共用体内存布局：

一：

```c
#include<stdio.h>union data{//由于输出结果相同//data是一个共用体，包含三个成员，共用一个数据空间//该空间的大小以 占用最大的成员 为准    int n;//4字节    char ch;//1字节    short m;//2字节};void main(){    union data a;//定义一个共用体变量a    printf("%d,%d",sizeof(a),sizeof(union data));//输出的值都是4    return 0;}
```

二：==一个成员被赋值，其他成员也会（无规律）赋值：==

```c
#include <stdio.h>union data{ // data 就是一个共用体(内存布局)， 包含三个成员, 共享数据空间, 该空间的大小以占用最大的成员为准int n;char ch;short m;};void main(){union data a; //定义两个一个 共用体变量 a  //一个成员被赋值，其他成员也会（无规律）赋值printf("%d, %d\n", sizeof(a), sizeof(union data) ); // 4, 4a.n = 0x40;//16 进制printf("%d, %c, %d\n", a.n, a.ch, a.m);a.ch = '9'; //printf("%d, %c, %d\n", a.n, a.ch, a.m);a.m = 0x2059;printf("%d, %c, %d\n", a.n, a.ch, a.m);a.n = 0x3E25AD54;printf("%d, %c, %d\n", a.n, a.ch, a.m);getchar();}
```

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-16_20-48-18.png)

#### 实践案例：

![](C:\Users\asus\Pictures\Screenshots\Snipaste_2020-12-16_20-51-07.png)

```c
#include<stdio.h>#include<stdlib.h>#include "string.h"#define TOTAL 2//人员总数//定义了一个结构体struct Person{    char name[20];//名字    int num;//编号    char sex;//性别  f女，m男    char profession;//职业 s学生 t老师    union{        float score;        char course[20];    }sc;//sc是一个共用体变量    //由于共用体只用一次，可以边定义共用体边定义该共用体变量    //也可以在结构体外面定义后再在里面进行共用体变量的定义};void main(){    int i;    struct Person persons[TOTAL];//定义一个结构体数组    //输入人员信息    for(i=0;i<TOTAL;i++){        printf("Input info:\n");        scanf("%s %d %c %c",persons[i].name,&(persons[i].num),&(persons[i].sex),&(persons[i].profession));//如果用逗号隔开，会全部输入第一个字符数组（字符串）中        if(persons[i].profession=='s'){//如果是学生            printf("请输入该学生的成绩：\n");            scanf("%f",&(persons[i].sc.score));        }        else if(persons[i].profession=='t'){//如果是老师            printf("请输入该老师授课的课程：\n");            scanf("%s",persons[i].sc.course);        }        fflush(stdin);//刷新输入，保证数据都进入结构体中    }    printf("\nName\t\tNum\tSex\tProfession\tScore/Course\n");    for(i=0;i<TOTAL;i++){        if(persons[i].profession == 's'){ //如果是学生              printf("%s\t\t%d\t%c\t%c\t\t%f\n", persons[i].name, persons[i].num, persons[i].sex, persons[i].profession,              persons[i].sc.score);         }        else{ //如果是老师              printf("%s\t\t%d\t%c\t%c\t\t%s\n", persons[i].name, persons[i].num, persons[i].sex, persons[i].profession,               persons[i].sc.course);}    }}
```

#### 共用体的补充：

**共用体与结构体的不同点：**

>

___

### 二十四、结构体的补充：

#### 用typedef定义数据类型：

![](C:\Users\asus\OneDrive\图片\屏幕快照\1608295350520.jpg)

关键字**typede**用于为系统固有的或程序员自定义的数据类型定义==另一个别名==。别名通常使用大写字母，为了与已有的数据类型相区分。例如：

```c
typedef int INTEGER;//为int定义了一个新的名字INTEGER，也就是说INTEGER与int同名
```

**为结构体定义一个别名：**

一：

```c
typedef struct student STUDENT;//将结构体定义一个新名字 STUDENT
```

二：

```c
typedef struct student{    long studentID;       //学号    char studentName[10];//姓名    char studentSex;     //性别    int yearOfBirth;     //出生年        int score[4];        //4门课程的成绩}STUDENT;
```

于是下面两个等价：

```c
STUDENT stu1,stu2;       //更简洁的形式struct student stu1,stu2;
```

==注意==：typedef 只是为一种已存在的类型定义一个新名字而已，并未定义一种新的数据类型。

#### 对上述定义的结构体初始化：

>定义一个结构体变量stu1，并对其进行初始化语句为：
>
>```c
>STUDENT stu1 = {1002310,"王刚",'M',1991,{72,83,90,82}};//等价于：struct student stu1 = {1002310,"王刚",'M',1991,{72,83,90,82}};//最后一个成员是整型数组被初始化为花括号内的数值(72,83,90,82)
>```
>
>对结构体STUDENT中 studentName[10] 成员的单独赋值：
>
>```c
>stu1.studentName = "王刚"//错误！！！该成员名只是数组的首地址//正确赋初始值方式：    strcpy(stu1.studentName,"王刚");//将“王刚”复制给姓名成员
>```
>
>![](C:\Users\asus\OneDrive\图片\屏幕快照\1608295898548.jpg)
>
>

#### 嵌套的结构体：

定义：就是在一个结构体内包含了另一个结构体作为其成员。

>需求：如果将上述定义的出生年修改为包含具体的年、月、日信息的日期，则需要先定义一个具有年、月、日成员的结构体类型，先声明一个日期结构体模板如下：
>
>```c
>typedef struct date{int year;int month;int day;}DATE; //将结构体用 DATE 重新命名
>```
>
>然后根据这个DATE结构体模板来声明STUDENT结构体模板
>
>```c
>typedef struct student{long studentID;   //学号char studentName[10];  //姓名char studentSex;   //性别DATE birthday;    //定义一个DATE结构体变量，记录出身日期int score[4];     //4门课程的成绩}STUDENT;    //将结构体用 STUDENT 表示
>```
>
>==注释==：在结构体定义中出现了“嵌套”，因为STUDENT结构体内包含了另一个DATE结构体类型的变量 birthday 作为成员，因此它是一个嵌套结构体。
>
>**对STUDENT结构体类型定义变量并初始化：**
>
>```c
>STUDENT stu1 = {1003210121,"王刚",'M',{1991,5,19},{72,83,90,82}};
>```
>
>**实际效果：**
>
>![](C:\Users\asus\OneDrive\图片\屏幕快照\IMG_20201218_210822.jpg)
>
>**将日期结构体模板设计成如下形式：**
>
>```c
>typedef struct date{int year;char month[10]; //定义一个字符数组（字符串）int day;}DATE;  //将结构体用DATE表示
>```
>
>**那么此时定义STUDENT类型的结构体变量 stu1 ，则对其进行初始化的方法将变成：**
>
>```c
>STUDENT stu1 = {100310121,"王刚",'M',{1991,"May",19},{72,83,90,82}};
>```
>
>==访问结构体变量的成员使用成员选择运算符（圆点运算符）：==
>
>```c
>结构体变量名 . 成员名stu1.studentID = 10031021;//为结构体变量stu1的studentID成员赋值
>```
>
>**当出现==结构体嵌套时==，必须以级联方式访问结构体成员，即通过成员选择运算符逐级找到最底层的成员时再引用**：
>
>下面三条语句用于对结构体变量stu1的birthday成员进行赋值：
>
>```c
>stu1.birthday.year = 1991;stu1.birthday.month = 5;stu1.birthday.day = 19;
>```

**C语言允许对具有相同结构体类型的变量进行整体赋值**：

>解释：实际上是按结构体的成员顺序逐一对相应的成员进行赋值，赋值后的结果就是两个结构体变量的成员具有相同内容。
>
>```c
>stu1 = stu2; //两个都是STUDENT结构体类型的变量stu1.studentID = stu2.studentID; //普通类型成员的赋值strcpy(stu1.studentName,stu2.studentName);//字符数组型成员的赋值stu1.birthday.year = stu2.birthday.year;//嵌套结构体成员的赋值//结构体数组赋值：stu1.score[0] = stu2.score[0];stu1.score[1] = stu2.score[1];.........
>```
>
>==并非所有的结构体成员都是可以使用赋值运算符来赋值，对字符串数组类型的结构体成员进行赋值时，必须使用字符串处理函数  strcpy( ).==

**结构体类型的声明可以在所有函数外，也可以在某个函数内**：

>在函数体外声明的可为所有函数使用，称为==全局声明==
>
>在函数体内声明的只能在本函数体内使用，离开该函数体，声明失效，称为==局部声明==

**要求从键盘输入结构体变量：**

>```c
>#include<stdio.h>typedef struct date{int year;int month;int day;}DATE;typedef struct student{long studentID;         //学号char studentName[10];   //名字char studentSex;        //性别DATE birthday;         // 出生时间：年，月，日int score[4];         //4门成绩}STUDENT;int main(){STUDENT stu1,stu2;int i;printf("输入学生的学号：\n");scanf("%ld",&stu1.studentID);printf("输入学生的姓名：\n");scanf("%s",stu1.studentName);//输入姓名不要地址符 &//C语言规定，数组名所代表的地址为第0个元素的地址，例如 char c[10]; ， c 就代表 c[0] 的地址。//第0个元素的地址就是数组的起始地址，称为 首地址 。 也就是说，数组名表示数组的首地址。//设数组c的首地址为0X2000，也即c[0]地址为0X2000，则数组名c就代表这个地址。//因为c已经表示地址，所以在c前面不能再加取地址符&，例如写作 scanf("%s",&c); 是没有道理的。printf("输入学生的性别：\n");scanf(" %c",&stu1.studentSex);//%c前有一个空格，吞噬前面的 回车//出生日期（嵌套结构体输入）printf("输入学生的出生年，月，日：\n");scanf("%d",&stu1.birthday.year);scanf("%d",&stu1.birthday.month);scanf("%d",&stu1.birthday.day);//根据遍历输入学生的4门成绩：for(i=0;i<4;i++){       printf("请输入成绩：\n");       scanf("%d",&stu1.score[i]);}stu2 = stu1;                //同类型的结构体变量之间的赋值操作printf("&stu2=%p\n",&stu2);//打印结构体变量stu2的地址printf("&stu1=%p\n",&stu1);//打印结构体变量stu1的地址（输出结果与stu2地址不一样）printf("%10ld %8s %3c %6d/ %02d/ %02d %4d %4d %4d %4d \n",stu2.studentID,stu2.studentName,stu2.studentSex,stu2.birthday.year,stu2.birthday.month,stu2.birthday.day,      stu2.score[0],stu2.score[1],stu2.score[2],stu2.score[3]);      return 0;}
>```
>
>==注意：==结构体模板只是声明了一种数据类型，定义了数据的组织形式，并未声明结构体类型的变量，因而编译器不为其分配内存，正如编译器不给int型分配内存一样。

**结构体所占内存的字节**：

>不同系统和编译器，内存对齐的方式有所不同，为了满足处理器的对齐要求，可能会在较小的成员后加入补应，从而导致结构体实际所占内存的字节数会比我们想象的多出一些字节。
>
>![](C:\Users\asus\OneDrive\图片\屏幕快照\1608301425725.jpg)

#### 结构体数组：

**结构体数组的定义**：

>```c
>//已经声明STUDENT结构体类型：//定义结构体数组：STUDENT stu[30];
>```
>
>它定义了一个有30个元素的结构体数组，每个元素的类型为STUDENT。该数组所占的内存字节数为：30*sizeof(STUDENT)。此时，访问第1个学生的学号用 ==stu[0].studentID==,访问第4个学生的出生年用 ==stu[3].birthday.year==。

**结构体数组的初始化：**

>定义一个STUDENT结构体：
>
>```c
>typedef struct student{long studentID;   //学号char studentName[10];  //姓名char studentSex;   //性别DATE birthday;    //定义一个DATE结构体变量，记录出身日期int score[4];     //4门课程的成绩}STUDENT;   
>```
>
>定义一个结构体数组：
>
>```c
>STUDENT stu[30];
>```
>
>对结构体数组的初始化：
>
>```c
>STUDENT stu[30] = {{1231,"王刚",'M',{1998,5,4},{89,76,78,79}},              {1345,"李晓明",'M',{1999,6,7},{89,79,90,99}}}//对前2个元素进行了初始化，而其他数组元素被系统自动赋值为 0 。
>```

#### 结构体指针的定义和初始化（指向运算符）：

**定义一个指向结构体类型（STUDENT）的指针变量：**

>```c
>STUDENT *pt;//定义指向STUDENT结构体的指针变量//类似于： int *pt;
>```
>
>这里只是定义了一个指向 STUDENT 结构体类型的指针变量 pt,但是**此时的 pt 并没有指向一个确定的存储单元**,其值是一个随机值。**为使 pt 指向一个确定的存储单元,需要对指针变量进行初始化**。例如,下面语句：
>
>```c
>pt = &stu1;//让结构体指针变量 pt 指向结构体变量 stul使指针 pt 指向结构体变量 stul 所占内存空间的首地址,即 pt是指向结构体变量 stul 的指针。
>```
>
>**还可以直接定义：**
>
>```c
>STUDENT *pt = &stu1;
>```

**访问结构体指针变量指向的成员**：

>```c
>stu1.studentID = 1;(*pt).studentID = 1;
>```
>
>等价于：**通过==指向运算符==访问**
>
>```c
>pt -> studentID = 1;
>```
>
>**访问结构体嵌套结构体中的成员**：
>
>```c
>stu1.birthday.year = 1999;//等价于：(*pt).birthday.year = 1999;//等价于：pt ->birthday.year = 1999;
>```

**指向结构体数组的指针：**

>定义一个结构体数组：
>
>```c
>STUDENT stu[30];
>```
>
>定义结构体指针变量pt并将其指向结构体数组stu的方法：
>
>```c
>STUDENT *pt = stu;//将数组的首地址传给 指针变量 pt//等价于：STUDENT *pt = &stu[0];//等价于：STUDENT *p;p = stu;//数组名表示数组的首地址
>```

**pt++是什么意思？**

>表示 增加 STUDENT  个字节单位。例如：pt指向stu[0]，则pt+1指向下个结构体数组元素 stu[1] 的首地址

#### 向函数传递结构体：

1. 向函数传递结构体的==单个成员==：
   * 复制**单个成员的内容**（对主函数中的结构体成员不发生改变）
2. 向函数传递结构体的==完整结构==：
   * 复制结构体的**所有成员**
3. 向函数传递结构体的==首地址==：
   * 仅复制**一个地址值**

**结构体变量作函数参数：**

**（向函数传递结构体的完整结构）**

```c
typedef struct point{    int x;    int y;    int z;}POINT;void Func(POINT p){//p是一个结构体类型的形参    p.x = 1;    p.y = 1;    p.z = 1;}int main(){    POINT position = {0,0,0};//定义一个结构体变量并赋初值    printf("Before:%d,%d,%d\n",position.x,position.y,position.z);//输出：0,0,0    Func(position);//传递了position所有成员的值 相当于：p = position;    printf("After:%d,%d,%d\n",position.x,position.y,position.z);//输出:0,0,0    return 0;}
```

**结论：**

原结构体的成员不会被被调函数的改变而改变，如果要使结构体变量中的成员传入被调函数后发生改变，则==使用结构体类型指针变量==传递地址：

**向函数传递结构体的首地址**：

```c
#include<stdio.h>#include<stdlib.h>#include<string.h>typedef struct point{    int x;    int y;    int z;}POINT;void Func(POINT *p){//结构体指针变量形参    (*p).x = 1;    (*p).y = 1;    (*p).z = 1;}int main(){    POINT position = {0,0,0};//定义一个结构体变量并赋初值    printf("Before:%d,%d,%d\n",position.x,position.y,position.z);    Func(&position);//传递一个结构体变量的地址    printf("After:%d,%d,%d\n",position.x,position.y,position.z);    return 0;}
```

**返回结构体变量也可以得到修改的结构体内容，但效率低：**(==要注意被调函数返回值的类型==)

```c
typedef struct point{    int x;    int y;    int z;}POINT;//被调函数返回值类型是POINT型POINT Func(POINT p){//p是一个结构体类型的形参    p.x = 1;    p.y = 1;    p.z = 1;    return p;}int main(){    POINT position = {0,0,0};//定义一个结构体变量并赋初值    printf("Before:%d,%d,%d\n",position.x,position.y,position.z);//输出：0,0,0    position = Func(position);//传递了position所有成员的值 相当于：p = position;    printf("After:%d,%d,%d\n",position.x,position.y,position.z);//输出:1,1,1    return 0;}
```

**使用指向运算符代替指针变量取值符，自定义输入结构体成员的数值：**

```c
#include<stdio.h>#include<stdlib.h>#include<string.h>typedef struct point{    int x;    int y;    int z;}POINT;//结构体更名为POINTvoid Func(POINT *p){//p是一个结构体类型指针变量的形参    //使用指向运算符寻找x,y,z的值：     p ->x = 1;     p ->y = 1;     p ->z = 1;}int main(){    POINT position;//定义一个结构体变量    printf("请输入结构体中x,y,z的值：\n");    scanf("%d,%d,%d",&position.x,&position.y,&position.z);    printf("Before:%d,%d,%d\n",position.x,position.y,position.z);    Func(&position);    printf("After:%d,%d,%d\n",position.x,position.y,position.z);    return 0;}
```

**如果不需要结构体在被调函数中被改变，则使用 const 保护结构体指针指向的结构体：**

```c
typedef struct point{    int x;    int y;    int z;}POINT;void Func(const POINT *pt)//用const保护结构体指针指向的结构体{    ......;    ......;}
```

#### 封装函数参数：

>需求：结构体数组作函数参数计算n个学生m门课程的平均分：
>
>* 先定义2个结构体记录每个学生的信息：
>
>```c
>typedef struct date{   int year;   int month;   int day;}DATE;typedef struct student{   long studentID;   char studentName[10];   char studentSex[5];   DATE birthday;   int score[4];}STUDENT;
>```
>
>* 主函数中的定义为：
>
>```c
>void AverScore(STUDENT stu[],float aver[],int n,int m){//float aver[]用来记录学生的平均分   int i,j,sum[N];   for(i=0;i<N;i++){//外层循环：N个学生的遍历       sum[i] = 0;       for(j=0;j<m;j++){//第i个学生的m门课程成绩累加在一起           sum[i]=sum[i]+sum[i].score[j];       }       aver[i] = (float)sum[i]/m;   }}
>```
>
>* **为了使函数更具有封装性，可以将学生的平均分·保留到学生信息结构体中：**
>
> * 结构体重新定义：
>
>   ```c
>   typedef struct date{    int year;    int month;    int day;}DATE;typedef struct student{    long studentID;    char studentName[10];    char studentSex[5];    DATE birthday;    int score[4];    float aver;//一个学生的m门成绩的平均分}STUDENT;
>   ```
>
> * 此时函数中可不再定义使用一个数组记录平均分：
>
>   ```c
>   void AverScore(STUDENT stu[],int n,int m){    int i,j,sum[N];    for(i=0;i<n;i++){//n个学生的遍历        sum[i] = 0;        for(j=0;j<m;j++)//学生m门课程的遍历        {            sum[i] = sum[i] + stu[i].score[j];//一个同学m门成绩的求和        }        stu[i].aver = (float)sum[i]/m;//结构体中一个学生的m门课程平均成绩    }}
>   ```

#### 结构体调用小结：

* **如何向函数传递结构体这样的大数据对象：**

  |     向函数传递结构体的==完整结构==     |       向函数传递结构体的==首地址==       |
  | :------------------------------------: | :--------------------------------------: |
  |         用结构体变量作函数参数         |    用结构体数组/结构体指针作函数参数     |
  |   复制整个结构体成员的内容，一组数据   |    仅复制结构体的首地址，==一个数据==    |
  |     参数传递直观，但开销大，效率低     |              参数传递效率高              |
  | 函数内对结构内容的修改**不影响结构体** | **可修改结构体**指针所指向的结构体的内容 |

  ==传递结构体的首地址或者指针传递时，如果不想主函数中结构体发生改变，可在参数列表中定义const来保护==

____

### 二十五、链表：

#### 指向运算符：

* 如何访问结构体指针变量所指向的结构体成员？

  * 方式一：成员选择运算符

    * ```c
      (*ptr).name;//指向结构体成员name
      ```

  * 方式二：指向运算符

    * ```c
      ptr->name;
      ```

#### 节点：

* 数据
* 指向下一节点的指针

#### 链表：

* 一系列节点
* 每个节点至少包括：
  * 一条数据（任意类型）
  * 一个该节点的类型的指针
  * 节点之间首尾相连（指向链表中下一个节点的指针）
* 头指针：指向第一个节点的指针
* 尾指针：节点指针指向空

#### 链表的使用：

```c
#include<stdio.h>#define N 20int main() {    struct Player{        char name[10];        int ID;        int Age;        struct Player *ptr;    };//    1.创建节点：    struct Player p1 = {"zyy",1,20};    struct Player p2 = {"zyt",3,18};    struct Player p3 = {"zyx",  9,17};//     创建相应类型的头指针：    struct Player *head;//    2.链：使每个节点的指针域存储后继节点的地址    head = &p1;    p1.ptr = &p2;    p2.ptr = &p3;    p3.ptr = NULL;    printf("The first player is %s",head->name);}
```

**封装化：**

```c
#include <stdio.h>struct Player{    char name[10];    int ID;    int Age;    struct Player *ptr;};struct Player *Built(void){    struct Player p1 = {"zyy",1,20};    struct Player p2 = {"zyt",3,18};    struct Player p3 = {"zyx",  9,17};    struct Player *head = &p1;    return head;}int main(){    struct Player *ptr;    ptr = Built();//    此时数据保存在栈当中。调用完Built方法后，自动销毁    printf("The first player is %s",ptr->name);//输出乱码}
```

**改进：**使用`malloc`动态申请内存空间

```c
#include <stdio.h>#include <malloc.h>#include <string.h>struct Player{    char name[10];    int ID;    int Age;    struct Player *ptr;};struct Player *Built(void){    struct Player *p1 = (struct Player*) malloc(sizeof (struct Player));    struct Player *p2 = (struct Player*) malloc(sizeof (struct Player));    struct Player *p3 = (struct Player*) malloc(sizeof (struct Player));    struct Player *head = p1;    strcpy(p1->name,"zyy");    p1->Age = 20;    p1->ID = 2;//    ............}int main(){    struct Player *ptr;    ptr = Built();//    此时数据保存在栈当中。调用完Built方法后，自动销毁    printf("The first player is %s",ptr->name);//输出乱码}
```

#### 建立多个节点的链表（动态申请列表）：

![](F:\Java语言学习\笔记保存的截图\Snipaste_2021-05-26_20-25-44.png)

```c
struct Player{    char name[10];    int ID;    int Age;    struct Player *ptr;};struct Player *Built(int num){//    prePt用来保存尾结点的地址，方便下一个节点的申请//     head保存头结点    struct Player *head,*prePt,*Pt;    Pt = (struct Player*) malloc(sizeof (struct Player));    if(Pt!=NULL){        scanf("%s%d%d",Pt->name,&Pt->ID,&Pt->Age);        head = Pt;//用head保存链表的首地址    } else{        printf("Failed!");        exit(0);    }    for (int i = 0; i < num; ++i) {        Pt = (struct Player*) malloc(sizeof (struct Player));        if(Pt!=NULL){            scanf("%s%d%d",Pt->name,&Pt->ID,&Pt->Age);            prePt->ptr = Pt;//用尾结点与新建节点连接            prePt = Pt;//更新尾结点        } else{            printf("Failed!");            exit(0);        }        Pt->ptr = NULL;//    或者：prPt->ptr = NULL;    }    return head;}
```

#### 在单项列表中查找节点：

**查找尾结点：**

> ```c
> struct Player *FindLast(struct Player *head){ struct Player *Pt = head; int i = 0; while(Pt->ptr!=NULL){     Pt = Pt->ptr;//如果不是，则指向下一个节点的地址（结构体）     i++; } return Pt;}
> ```

**查找第n个节点：**

> ```c
> struct Player *FindLast(struct Player *head,int index){ struct Player *Pt = head; int i = 0; while(i<index&&Pt->ptr!=NULL){     Pt = Pt->ptr;//如果不是，则指向下一个节点的地址（结构体）     i++; } return Pt;}
> ```

#### **项单向链表中插入一个字节点**：

![](F:\Java语言学习\笔记保存的截图\Snipaste_2021-05-26_21-09-10.png)

#### **删除单向链表的某个节点**：

![](F:\Java语言学习\笔记保存的截图\Snipaste_2021-05-26_21-13-34.png)

* 寻找到要删除的节点的前一个节点，来获取目的节点的地址
* 调用目的节点的前一个节点的存储指针变量，重新赋值与目的节点的下一个节点地址值
* 调用`free();`函数清除目的节点所占的空间